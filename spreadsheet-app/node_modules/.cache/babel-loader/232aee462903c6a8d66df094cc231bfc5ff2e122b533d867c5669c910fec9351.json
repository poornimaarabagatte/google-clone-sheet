{"ast":null,"code":"import { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { escape } from '../../utils/string.js';\nimport { forEach, join } from '../../utils/array.js';\nimport { toSymbol } from '../../utils/latex.js';\nimport { getPrecedence } from '../operators.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    Node\n  } = _ref;\n\n  /**\n   * @constructor FunctionAssignmentNode\n   * @extends {Node}\n   * Function assignment\n   *\n   * @param {string} name           Function name\n   * @param {string[] | Array.<{name: string, type: string}>} params\n   *                                Array with function parameter names, or an\n   *                                array with objects containing the name\n   *                                and type of the parameter\n   * @param {Node} expr             The function expression\n   */\n  function FunctionAssignmentNode(name, params, expr) {\n    if (!(this instanceof FunctionAssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n    if (!isNode(expr)) throw new TypeError('Node expected for parameter \"expr\"');\n    if (keywords.has(name)) throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n    this.name = name;\n    this.params = params.map(function (param) {\n      return param && param.name || param;\n    });\n    this.types = params.map(function (param) {\n      return param && param.type || 'any';\n    });\n    this.expr = expr;\n  }\n  FunctionAssignmentNode.prototype = new Node();\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionAssignmentNode.prototype._compile = function (math, argNames) {\n    var childArgNames = Object.create(argNames);\n    forEach(this.params, function (param) {\n      childArgNames[param] = true;\n    }); // compile the function expression with the child args\n\n    var evalExpr = this.expr._compile(math, childArgNames);\n    var name = this.name;\n    var params = this.params;\n    var signature = join(this.types, ',');\n    var syntax = name + '(' + join(this.params, ', ') + ')';\n    return function evalFunctionAssignmentNode(scope, args, context) {\n      var signatures = {};\n      signatures[signature] = function () {\n        var childArgs = Object.create(args);\n        for (var i = 0; i < params.length; i++) {\n          childArgs[params[i]] = arguments[i];\n        }\n        return evalExpr(scope, childArgs, context);\n      };\n      var fn = typed(name, signatures);\n      fn.syntax = syntax;\n      scope.set(name, fn);\n      return fn;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\n    callback(this.expr, 'expr', this);\n  };\n  /**\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n   */\n\n  FunctionAssignmentNode.prototype.map = function (callback) {\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionAssignmentNode}\n   */\n\n  FunctionAssignmentNode.prototype.clone = function () {\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n  };\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @private\n   */\n\n  function needParenthesis(node, parenthesis) {\n    var precedence = getPrecedence(node, parenthesis);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  /**\n   * get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionAssignmentNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toString(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = '(' + expr + ')';\n    }\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  FunctionAssignmentNode.prototype.toJSON = function () {\n    var types = this.types;\n    return {\n      mathjs: 'FunctionAssignmentNode',\n      name: this.name,\n      params: this.params.map(function (param, index) {\n        return {\n          name: param,\n          type: types[index]\n        };\n      }),\n      expr: this.expr\n    };\n  };\n  /**\n   * Instantiate an FunctionAssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionAssignmentNode\", name: ..., params: ..., expr: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionAssignmentNode}\n   */\n\n  FunctionAssignmentNode.fromJSON = function (json) {\n    return new FunctionAssignmentNode(json.name, json.params, json.expr);\n  };\n  /**\n   * get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionAssignmentNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var params = [];\n    for (var i = 0; i < this.params.length; i++) {\n      params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n    }\n    var expr = this.expr.toHTML(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span><span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n  };\n  /**\n   * get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionAssignmentNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toTex(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n    }\n    return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\n  };\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isNode","keywords","escape","forEach","join","toSymbol","getPrecedence","factory","name","dependencies","createFunctionAssignmentNode","_ref","typed","Node","FunctionAssignmentNode","params","expr","SyntaxError","TypeError","Array","isArray","has","Error","map","param","types","type","prototype","isFunctionAssignmentNode","_compile","math","argNames","childArgNames","Object","create","evalExpr","signature","syntax","evalFunctionAssignmentNode","scope","args","context","signatures","childArgs","i","length","arguments","fn","set","callback","_ifNode","slice","clone","needParenthesis","node","parenthesis","precedence","exprPrecedence","_toString","options","toString","toJSON","mathjs","index","fromJSON","json","toHTML","push","_toTex","toTex","concat","isClass"],"sources":["/Users/poornima/Desktop/Google_Sheet/spreadsheet-app/node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js"],"sourcesContent":["import { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { escape } from '../../utils/string.js';\nimport { forEach, join } from '../../utils/array.js';\nimport { toSymbol } from '../../utils/latex.js';\nimport { getPrecedence } from '../operators.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    Node\n  } = _ref;\n\n  /**\n   * @constructor FunctionAssignmentNode\n   * @extends {Node}\n   * Function assignment\n   *\n   * @param {string} name           Function name\n   * @param {string[] | Array.<{name: string, type: string}>} params\n   *                                Array with function parameter names, or an\n   *                                array with objects containing the name\n   *                                and type of the parameter\n   * @param {Node} expr             The function expression\n   */\n  function FunctionAssignmentNode(name, params, expr) {\n    if (!(this instanceof FunctionAssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n    if (!isNode(expr)) throw new TypeError('Node expected for parameter \"expr\"');\n    if (keywords.has(name)) throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n    this.name = name;\n    this.params = params.map(function (param) {\n      return param && param.name || param;\n    });\n    this.types = params.map(function (param) {\n      return param && param.type || 'any';\n    });\n    this.expr = expr;\n  }\n\n  FunctionAssignmentNode.prototype = new Node();\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionAssignmentNode.prototype._compile = function (math, argNames) {\n    var childArgNames = Object.create(argNames);\n    forEach(this.params, function (param) {\n      childArgNames[param] = true;\n    }); // compile the function expression with the child args\n\n    var evalExpr = this.expr._compile(math, childArgNames);\n\n    var name = this.name;\n    var params = this.params;\n    var signature = join(this.types, ',');\n    var syntax = name + '(' + join(this.params, ', ') + ')';\n    return function evalFunctionAssignmentNode(scope, args, context) {\n      var signatures = {};\n\n      signatures[signature] = function () {\n        var childArgs = Object.create(args);\n\n        for (var i = 0; i < params.length; i++) {\n          childArgs[params[i]] = arguments[i];\n        }\n\n        return evalExpr(scope, childArgs, context);\n      };\n\n      var fn = typed(name, signatures);\n      fn.syntax = syntax;\n      scope.set(name, fn);\n      return fn;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\n    callback(this.expr, 'expr', this);\n  };\n  /**\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionAssignmentNode.prototype.map = function (callback) {\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\n\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.prototype.clone = function () {\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n  };\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @private\n   */\n\n\n  function needParenthesis(node, parenthesis) {\n    var precedence = getPrecedence(node, parenthesis);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  /**\n   * get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toString(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '(' + expr + ')';\n    }\n\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionAssignmentNode.prototype.toJSON = function () {\n    var types = this.types;\n    return {\n      mathjs: 'FunctionAssignmentNode',\n      name: this.name,\n      params: this.params.map(function (param, index) {\n        return {\n          name: param,\n          type: types[index]\n        };\n      }),\n      expr: this.expr\n    };\n  };\n  /**\n   * Instantiate an FunctionAssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionAssignmentNode\", name: ..., params: ..., expr: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.fromJSON = function (json) {\n    return new FunctionAssignmentNode(json.name, json.params, json.expr);\n  };\n  /**\n   * get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var params = [];\n\n    for (var i = 0; i < this.params.length; i++) {\n      params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n    }\n\n    var expr = this.expr.toHTML(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span><span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n  };\n  /**\n   * get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toTex(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n    }\n\n    return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\n  };\n\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}