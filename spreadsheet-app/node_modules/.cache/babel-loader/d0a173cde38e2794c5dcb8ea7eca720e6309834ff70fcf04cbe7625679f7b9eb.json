{"ast":null,"code":"import { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { escape } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Range,\n    Node,\n    size\n  } = _ref;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n          var evalStart = range.start._compile(math, childArgNames);\n          var evalEnd = range.end._compile(math, childArgNames);\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n          var _evalEnd = range.end._compile(math, argNames);\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n        _childArgNames.end = true;\n        var evalRange = range._compile(math, _childArgNames);\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index(...dimensions);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isBigNumber","isConstantNode","isNode","isRangeNode","isSymbolNode","map","escape","factory","getSafeProperty","name","dependencies","createIndexNode","_ref","Range","Node","size","IndexNode","dimensions","dotNotation","SyntaxError","Array","isArray","every","TypeError","isObjectProperty","Error","prototype","type","isIndexNode","_compile","math","argNames","evalDimensions","range","i","needsEnd","childArgNames","Object","create","end","evalStart","start","evalEnd","evalStep","step","evalDimension","scope","args","context","s","valueOf","childArgs","createRange","_evalStart","_evalEnd","_evalStep","_childArgNames","evalRange","_evalRange","index","evalIndexNode","forEach","callback","length","_ifNode","clone","slice","value","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","toNumber","isClass"],"sources":["/Users/poornima/Desktop/Google_Sheet/spreadsheet-app/node_modules/mathjs/lib/esm/expression/node/IndexNode.js"],"sourcesContent":["import { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { escape } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Range,\n    Node,\n    size\n  } = _ref;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index(...dimensions);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}