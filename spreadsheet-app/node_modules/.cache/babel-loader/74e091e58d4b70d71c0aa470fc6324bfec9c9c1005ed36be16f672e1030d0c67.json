{"ast":null,"code":"import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'unaryMinus', 'lup'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    multiply,\n    unaryMinus,\n    lup\n  } = _ref;\n\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n        case 2:\n          {\n            // two dimensional array\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Compute the LU decomposition\n      var decomp = lup(matrix); // The determinant is the product of the diagonal entries of U (and those of L, but they are all 1)\n\n      var det = decomp.U[0][0];\n      for (var _i = 1; _i < rows; _i++) {\n        det = multiply(det, decomp.U[_i][_i]);\n      } // The determinant will be multiplied by 1 or -1 depending on the parity of the permutation matrix.\n      // This can be determined by counting the cycles. This is roughly a linear time algorithm.\n\n      var evenCycles = 0;\n      var i = 0;\n      var visited = [];\n      while (true) {\n        while (visited[i]) {\n          i++;\n        }\n        if (i >= rows) break;\n        var j = i;\n        var cycleLen = 0;\n        while (!visited[decomp.p[j]]) {\n          visited[decomp.p[j]] = true;\n          j = decomp.p[j];\n          cycleLen++;\n        }\n        if (cycleLen % 2 === 0) {\n          evenCycles++;\n        }\n      }\n      return evenCycles % 2 === 0 ? det : unaryMinus(det);\n    }\n  }\n});","map":{"version":3,"names":["isMatrix","clone","format","factory","name","dependencies","createDet","_ref","typed","matrix","subtract","multiply","unaryMinus","lup","any","x","det","size","Array","isArray","length","valueOf","RangeError","rows","cols","_det","decomp","U","_i","evenCycles","i","visited","j","cycleLen","p"],"sources":["/Users/poornima/Desktop/Google_Sheet/spreadsheet-app/node_modules/mathjs/lib/esm/function/matrix/det.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'unaryMinus', 'lup'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    multiply,\n    unaryMinus,\n    lup\n  } = _ref;\n\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n\n        case 2:\n          {\n            // two dimensional array\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Compute the LU decomposition\n      var decomp = lup(matrix); // The determinant is the product of the diagonal entries of U (and those of L, but they are all 1)\n\n      var det = decomp.U[0][0];\n\n      for (var _i = 1; _i < rows; _i++) {\n        det = multiply(det, decomp.U[_i][_i]);\n      } // The determinant will be multiplied by 1 or -1 depending on the parity of the permutation matrix.\n      // This can be determined by counting the cycles. This is roughly a linear time algorithm.\n\n\n      var evenCycles = 0;\n      var i = 0;\n      var visited = [];\n\n      while (true) {\n        while (visited[i]) {\n          i++;\n        }\n\n        if (i >= rows) break;\n        var j = i;\n        var cycleLen = 0;\n\n        while (!visited[decomp.p[j]]) {\n          visited[decomp.p[j]] = true;\n          j = decomp.p[j];\n          cycleLen++;\n        }\n\n        if (cycleLen % 2 === 0) {\n          evenCycles++;\n        }\n      }\n\n      return evenCycles % 2 === 0 ? det : unaryMinus(det);\n    }\n  }\n});"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,mBAAmB;AAC5C,SAASC,KAAK,QAAQ,uBAAuB;AAC7C,SAASC,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,OAAO,QAAQ,wBAAwB;AAChD,IAAIC,IAAI,GAAG,KAAK;AAChB,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,UAAU,EAAE,YAAY,EAAE,KAAK,CAAC;AACnF,OAAO,IAAIC,SAAS,GAAG,eAAeH,OAAO,CAACC,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EACxE,IAAI;IACFC,KAAK;IACLC,MAAM;IACNC,QAAQ;IACRC,QAAQ;IACRC,UAAU;IACVC;EACF,CAAC,GAAGN,IAAI;;EAER;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,KAAK,CAACJ,IAAI,EAAE;IACjBU,GAAG,EAAE,SAASA,GAAGA,CAACC,CAAC,EAAE;MACnB,OAAOd,KAAK,CAACc,CAAC,CAAC;IACjB,CAAC;IACD,gBAAgB,EAAE,SAASC,GAAGA,CAACD,CAAC,EAAE;MAChC,IAAIE,IAAI;MAER,IAAIjB,QAAQ,CAACe,CAAC,CAAC,EAAE;QACfE,IAAI,GAAGF,CAAC,CAACE,IAAI,CAAC,CAAC;MACjB,CAAC,MAAM,IAAIC,KAAK,CAACC,OAAO,CAACJ,CAAC,CAAC,EAAE;QAC3BA,CAAC,GAAGN,MAAM,CAACM,CAAC,CAAC;QACbE,IAAI,GAAGF,CAAC,CAACE,IAAI,CAAC,CAAC;MACjB,CAAC,MAAM;QACL;QACAA,IAAI,GAAG,EAAE;MACX;MAEA,QAAQA,IAAI,CAACG,MAAM;QACjB,KAAK,CAAC;UACJ;UACA,OAAOnB,KAAK,CAACc,CAAC,CAAC;QAEjB,KAAK,CAAC;UACJ;UACA,IAAIE,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;YACjB,OAAOhB,KAAK,CAACc,CAAC,CAACM,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;UAC9B,CAAC,MAAM;YACL,MAAM,IAAIC,UAAU,CAAC,wBAAwB,GAAG,SAAS,GAAGpB,MAAM,CAACe,IAAI,CAAC,GAAG,GAAG,CAAC;UACjF;QAEF,KAAK,CAAC;UACJ;YACE;YACA,IAAIM,IAAI,GAAGN,IAAI,CAAC,CAAC,CAAC;YAClB,IAAIO,IAAI,GAAGP,IAAI,CAAC,CAAC,CAAC;YAElB,IAAIM,IAAI,KAAKC,IAAI,EAAE;cACjB,OAAOC,IAAI,CAACV,CAAC,CAACd,KAAK,CAAC,CAAC,CAACoB,OAAO,CAAC,CAAC,EAAEE,IAAI,EAAEC,IAAI,CAAC;YAC9C,CAAC,MAAM;cACL,MAAM,IAAIF,UAAU,CAAC,wBAAwB,GAAG,SAAS,GAAGpB,MAAM,CAACe,IAAI,CAAC,GAAG,GAAG,CAAC;YACjF;UACF;QAEF;UACE;UACA,MAAM,IAAIK,UAAU,CAAC,iCAAiC,GAAG,SAAS,GAAGpB,MAAM,CAACe,IAAI,CAAC,GAAG,GAAG,CAAC;MAC5F;IACF;EACF,CAAC,CAAC;EACF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE,SAASQ,IAAIA,CAAChB,MAAM,EAAEc,IAAI,EAAEC,IAAI,EAAE;IAChC,IAAID,IAAI,KAAK,CAAC,EAAE;MACd;MACA,OAAOtB,KAAK,CAACQ,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5B,CAAC,MAAM,IAAIc,IAAI,KAAK,CAAC,EAAE;MACrB;MACA;MACA,OAAOb,QAAQ,CAACC,QAAQ,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEE,QAAQ,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7F,CAAC,MAAM;MACL;MACA,IAAIiB,MAAM,GAAGb,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC;;MAE1B,IAAIO,GAAG,GAAGU,MAAM,CAACC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAExB,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGL,IAAI,EAAEK,EAAE,EAAE,EAAE;QAChCZ,GAAG,GAAGL,QAAQ,CAACK,GAAG,EAAEU,MAAM,CAACC,CAAC,CAACC,EAAE,CAAC,CAACA,EAAE,CAAC,CAAC;MACvC,CAAC,CAAC;MACF;;MAGA,IAAIC,UAAU,GAAG,CAAC;MAClB,IAAIC,CAAC,GAAG,CAAC;MACT,IAAIC,OAAO,GAAG,EAAE;MAEhB,OAAO,IAAI,EAAE;QACX,OAAOA,OAAO,CAACD,CAAC,CAAC,EAAE;UACjBA,CAAC,EAAE;QACL;QAEA,IAAIA,CAAC,IAAIP,IAAI,EAAE;QACf,IAAIS,CAAC,GAAGF,CAAC;QACT,IAAIG,QAAQ,GAAG,CAAC;QAEhB,OAAO,CAACF,OAAO,CAACL,MAAM,CAACQ,CAAC,CAACF,CAAC,CAAC,CAAC,EAAE;UAC5BD,OAAO,CAACL,MAAM,CAACQ,CAAC,CAACF,CAAC,CAAC,CAAC,GAAG,IAAI;UAC3BA,CAAC,GAAGN,MAAM,CAACQ,CAAC,CAACF,CAAC,CAAC;UACfC,QAAQ,EAAE;QACZ;QAEA,IAAIA,QAAQ,GAAG,CAAC,KAAK,CAAC,EAAE;UACtBJ,UAAU,EAAE;QACd;MACF;MAEA,OAAOA,UAAU,GAAG,CAAC,KAAK,CAAC,GAAGb,GAAG,GAAGJ,UAAU,CAACI,GAAG,CAAC;IACrD;EACF;AACF,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}