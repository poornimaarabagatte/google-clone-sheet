{"ast":null,"code":"/**\n * Computes the elimination tree of Matrix A (using triu(A)) or the\n * elimination tree of A'A without forming A'A.\n *\n * @param {Matrix}  a               The A Matrix\n * @param {boolean} ata             A value of true the function computes the etree of A'A\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nexport function csEtree(a, ata) {\n  // check inputs\n  if (!a) {\n    return null;\n  } // a arrays\n\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size; // rows & columns\n\n  var m = asize[0];\n  var n = asize[1]; // allocate result\n\n  var parent = []; // (n)\n  // allocate workspace\n\n  var w = []; // (n + (ata ? m : 0))\n\n  var ancestor = 0; // first n entries in w\n\n  var prev = n; // last m entries (ata = true)\n\n  var i, inext; // check we are calculating A'A\n\n  if (ata) {\n    // initialize workspace\n    for (i = 0; i < m; i++) {\n      w[prev + i] = -1;\n    }\n  } // loop columns\n\n  for (var k = 0; k < n; k++) {\n    // node k has no parent yet\n    parent[k] = -1; // nor does k have an ancestor\n\n    w[ancestor + k] = -1; // values in column k\n\n    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n      // row\n      var r = aindex[p]; // node\n\n      i = ata ? w[prev + r] : r; // traverse from i to k\n\n      for (; i !== -1 && i < k; i = inext) {\n        // inext = ancestor of i\n        inext = w[ancestor + i]; // path compression\n\n        w[ancestor + i] = k; // check no anc., parent is k\n\n        if (inext === -1) {\n          parent[i] = k;\n        }\n      }\n      if (ata) {\n        w[prev + r] = k;\n      }\n    }\n  }\n  return parent;\n}","map":{"version":3,"names":["csEtree","a","ata","aindex","_index","aptr","_ptr","asize","_size","m","n","parent","w","ancestor","prev","i","inext","k","p0","p1","p","r"],"sources":["/Users/poornima/Desktop/Google_Sheet/spreadsheet-app/node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js"],"sourcesContent":["/**\n * Computes the elimination tree of Matrix A (using triu(A)) or the\n * elimination tree of A'A without forming A'A.\n *\n * @param {Matrix}  a               The A Matrix\n * @param {boolean} ata             A value of true the function computes the etree of A'A\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nexport function csEtree(a, ata) {\n  // check inputs\n  if (!a) {\n    return null;\n  } // a arrays\n\n\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size; // rows & columns\n\n  var m = asize[0];\n  var n = asize[1]; // allocate result\n\n  var parent = []; // (n)\n  // allocate workspace\n\n  var w = []; // (n + (ata ? m : 0))\n\n  var ancestor = 0; // first n entries in w\n\n  var prev = n; // last m entries (ata = true)\n\n  var i, inext; // check we are calculating A'A\n\n  if (ata) {\n    // initialize workspace\n    for (i = 0; i < m; i++) {\n      w[prev + i] = -1;\n    }\n  } // loop columns\n\n\n  for (var k = 0; k < n; k++) {\n    // node k has no parent yet\n    parent[k] = -1; // nor does k have an ancestor\n\n    w[ancestor + k] = -1; // values in column k\n\n    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n      // row\n      var r = aindex[p]; // node\n\n      i = ata ? w[prev + r] : r; // traverse from i to k\n\n      for (; i !== -1 && i < k; i = inext) {\n        // inext = ancestor of i\n        inext = w[ancestor + i]; // path compression\n\n        w[ancestor + i] = k; // check no anc., parent is k\n\n        if (inext === -1) {\n          parent[i] = k;\n        }\n      }\n\n      if (ata) {\n        w[prev + r] = k;\n      }\n    }\n  }\n\n  return parent;\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,OAAOA,CAACC,CAAC,EAAEC,GAAG,EAAE;EAC9B;EACA,IAAI,CAACD,CAAC,EAAE;IACN,OAAO,IAAI;EACb,CAAC,CAAC;;EAGF,IAAIE,MAAM,GAAGF,CAAC,CAACG,MAAM;EACrB,IAAIC,IAAI,GAAGJ,CAAC,CAACK,IAAI;EACjB,IAAIC,KAAK,GAAGN,CAAC,CAACO,KAAK,CAAC,CAAC;;EAErB,IAAIC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC;EAChB,IAAIG,CAAC,GAAGH,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;EAElB,IAAII,MAAM,GAAG,EAAE,CAAC,CAAC;EACjB;;EAEA,IAAIC,CAAC,GAAG,EAAE,CAAC,CAAC;;EAEZ,IAAIC,QAAQ,GAAG,CAAC,CAAC,CAAC;;EAElB,IAAIC,IAAI,GAAGJ,CAAC,CAAC,CAAC;;EAEd,IAAIK,CAAC,EAAEC,KAAK,CAAC,CAAC;;EAEd,IAAId,GAAG,EAAE;IACP;IACA,KAAKa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,CAAC,EAAEM,CAAC,EAAE,EAAE;MACtBH,CAAC,CAACE,IAAI,GAAGC,CAAC,CAAC,GAAG,CAAC,CAAC;IAClB;EACF,CAAC,CAAC;;EAGF,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,EAAEO,CAAC,EAAE,EAAE;IAC1B;IACAN,MAAM,CAACM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;IAEhBL,CAAC,CAACC,QAAQ,GAAGI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;IAEtB,KAAK,IAAIC,EAAE,GAAGb,IAAI,CAACY,CAAC,CAAC,EAAEE,EAAE,GAAGd,IAAI,CAACY,CAAC,GAAG,CAAC,CAAC,EAAEG,CAAC,GAAGF,EAAE,EAAEE,CAAC,GAAGD,EAAE,EAAEC,CAAC,EAAE,EAAE;MAC5D;MACA,IAAIC,CAAC,GAAGlB,MAAM,CAACiB,CAAC,CAAC,CAAC,CAAC;;MAEnBL,CAAC,GAAGb,GAAG,GAAGU,CAAC,CAACE,IAAI,GAAGO,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC;;MAE3B,OAAON,CAAC,KAAK,CAAC,CAAC,IAAIA,CAAC,GAAGE,CAAC,EAAEF,CAAC,GAAGC,KAAK,EAAE;QACnC;QACAA,KAAK,GAAGJ,CAAC,CAACC,QAAQ,GAAGE,CAAC,CAAC,CAAC,CAAC;;QAEzBH,CAAC,CAACC,QAAQ,GAAGE,CAAC,CAAC,GAAGE,CAAC,CAAC,CAAC;;QAErB,IAAID,KAAK,KAAK,CAAC,CAAC,EAAE;UAChBL,MAAM,CAACI,CAAC,CAAC,GAAGE,CAAC;QACf;MACF;MAEA,IAAIf,GAAG,EAAE;QACPU,CAAC,CAACE,IAAI,GAAGO,CAAC,CAAC,GAAGJ,CAAC;MACjB;IACF;EACF;EAEA,OAAON,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}