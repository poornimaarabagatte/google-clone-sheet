{"ast":null,"code":"/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n})(this, function () {\n  function ok() {\n    return true;\n  }\n  function notOk() {\n    return false;\n  }\n  function undef() {\n    return undefined;\n  }\n\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n\n  // create a new instance of typed-function\n  function create() {\n    // data type tests\n    var _types = [{\n      name: 'number',\n      test: function (x) {\n        return typeof x === 'number';\n      }\n    }, {\n      name: 'string',\n      test: function (x) {\n        return typeof x === 'string';\n      }\n    }, {\n      name: 'boolean',\n      test: function (x) {\n        return typeof x === 'boolean';\n      }\n    }, {\n      name: 'Function',\n      test: function (x) {\n        return typeof x === 'function';\n      }\n    }, {\n      name: 'Array',\n      test: Array.isArray\n    }, {\n      name: 'Date',\n      test: function (x) {\n        return x instanceof Date;\n      }\n    }, {\n      name: 'RegExp',\n      test: function (x) {\n        return x instanceof RegExp;\n      }\n    }, {\n      name: 'Object',\n      test: function (x) {\n        return typeof x === 'object' && x !== null && x.constructor === Object;\n      }\n    }, {\n      name: 'null',\n      test: function (x) {\n        return x === null;\n      }\n    }, {\n      name: 'undefined',\n      test: function (x) {\n        return x === undefined;\n      }\n    }];\n    var anyType = {\n      name: 'any',\n      test: ok\n    };\n\n    // types which need to be ignored\n    var _ignore = [];\n\n    // type conversions\n    var _conversions = [];\n\n    // This is a temporary object, will be replaced with a typed function at the end\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n    function findTypeByName(typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n      if (entry) {\n        return entry;\n      }\n      if (typeName === 'any') {\n        // special baked-in case 'any'\n        return anyType;\n      }\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n      throw new TypeError('Unknown type \"' + typeName + '\"' + (hint ? '. Did you mean \"' + hint.name + '\"?' : ''));\n    }\n\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n      return typed.types.indexOf(type);\n    }\n\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n      if (entry) {\n        return entry.name;\n      }\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n    function find(fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      }\n\n      // normalize input\n      var arr;\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      } else if (Array.isArray(signature)) {\n        arr = signature;\n      } else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n      var str = arr.join(',');\n\n      // find an exact match\n      var match = fn.signatures[str];\n      if (match) {\n        return match;\n      }\n\n      // TODO: extend find to match non-exact signatures\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n    function convert(value, type) {\n      var from = findTypeName(value);\n\n      // check conversion is needed\n      if (type === from) {\n        return value;\n      }\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n\n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n    function stringifyParams(params) {\n      return params.map(function (param) {\n        var typeNames = param.types.map(getTypeName);\n        return (param.restParam ? '...' : '') + typeNames.join('|');\n      }).join(',');\n    }\n\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n    function parseParam(param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = !restParam ? param : param.length > 3 ? param.slice(3) : 'any';\n      var typeNames = types.split('|').map(trim).filter(notEmpty).filter(notIgnore);\n      var matchingConversions = filterConversions(conversions, typeNames);\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n    function parseSignature(signature, fn, conversions) {\n      var params = [];\n      if (signature.trim() !== '') {\n        params = signature.split(',').map(trim).map(function (param, index, array) {\n          var parsedParam = parseParam(param, conversions);\n          if (parsedParam.restParam && index !== array.length - 1) {\n            throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' + 'only allowed for the last parameter');\n          }\n          return parsedParam;\n        });\n      }\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n    function hasRestParam(params) {\n      var param = last(params);\n      return param ? param.restParam : false;\n    }\n\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      } else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      } else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        };\n      } else {\n        // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        });\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n    }\n\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n    function compileTests(params) {\n      var tests, test0, test1;\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n        var testRestParam = function (args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n          return true;\n        };\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n          return testRestParam(args) && args.length >= varIndex + 1;\n        };\n      } else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        } else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        } else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        } else {\n          // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length ? signature.params[index] : hasRestParam(signature.params) ? last(signature.params) : null;\n    }\n\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n    function getExpectedTypeNames(signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param ? excludeConversions ? param.types.filter(isExactType) : param.types : [];\n      return types.map(getTypeName);\n    }\n\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n    function getTypeName(type) {\n      return type.name;\n    }\n\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n      return typeNames.indexOf('any') !== -1 ? ['any'] : typeNames;\n    }\n\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n    function createError(name, args, signatures) {\n      var err, expected;\n      var _name = name || 'unnamed';\n\n      // test for wrong type at some index\n      var matchingSignatures = signatures;\n      var index;\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) && test(args[index]);\n        });\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n            err = new TypeError('Unexpected type of argument in function ' + _name + ' (expected: ' + expected.join(' or ') + ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            };\n            return err;\n          }\n        } else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      }\n\n      // test for too few arguments\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name + ' (expected: ' + expected.join(' or ') + ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        };\n        return err;\n      }\n\n      // test for too many arguments\n      var maxLength = Math.max.apply(null, lengths);\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name + ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        };\n        return err;\n      }\n      err = new TypeError('Arguments of type \"' + args.join(', ') + '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      };\n      return err;\n    }\n\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n    function getLowestTypeIndex(param) {\n      var min = 999;\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n      return min;\n    }\n\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n    function getLowestConversionIndex(param) {\n      var min = 999;\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n      return min;\n    }\n\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareParams(param1, param2) {\n      var c;\n\n      // compare having a rest parameter or not\n      c = param1.restParam - param2.restParam;\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare having conversions or not\n      c = hasConversions(param1) - hasConversions(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of the types\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of any conversion\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareSignatures(signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c;\n\n      // compare whether the params have conversions at all or not\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);\n      if (c !== 0) {\n        return c;\n      }\n\n      // next compare whether the params have conversions one by one\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the types of the params one by one\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the number of params\n      return signature1.params.length - signature2.params.length;\n    }\n\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 && typeNames.indexOf(conversion.to) !== -1 && !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn;\n\n      // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion);\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n          return fn.apply(this, args);\n        };\n      }\n      var fnPreprocess = fnConvert;\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n        fnPreprocess = function preprocessRestParams() {\n          return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        };\n      }\n      return fnPreprocess;\n    }\n\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      });\n\n      // create optimized conversion functions depending on the number of conversions\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          };\n        case 1:\n          test0 = tests[0];\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg);\n            }\n            return arg;\n          };\n        case 2:\n          test0 = tests[0];\n          test1 = tests[1];\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg);\n            }\n            if (test1(arg)) {\n              return conversion1(arg);\n            }\n            return arg;\n          };\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n            return arg;\n          };\n      }\n    }\n\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n      return signaturesMap;\n    }\n\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index];\n          var filteredTypes = ignoreConversionTypes ? param.types.filter(isExactType) : param.types;\n          var typeGroups;\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType);\n            typeGroups = exactTypes.length < filteredTypes.length ? [exactTypes, filteredTypes] : [filteredTypes];\n          } else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type];\n            });\n          }\n\n          // recurse over the groups with types\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n        } else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: typeIndex === params.length - 1 && hasRestParam(params)\n            };\n          });\n          return [splittedParams];\n        }\n      }\n      return _splitParams(params, 0, []);\n    }\n\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n      return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;\n    }\n\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      }\n\n      // parse the signatures, and check for conflicts\n      var parsedSignatures = [];\n      Object.keys(signaturesMap).map(function (signature) {\n        return parseSignature(signature, signaturesMap[signature], typed.conversions);\n      }).filter(notNull).forEach(function (parsedSignature) {\n        // check whether this parameter conflicts with already parsed signatures\n        var conflictingSignature = findInArray(parsedSignatures, function (s) {\n          return hasConflictingParams(s, parsedSignature);\n        });\n        if (conflictingSignature) {\n          throw new TypeError('Conflicting signatures \"' + stringifyParams(conflictingSignature.params) + '\" and \"' + stringifyParams(parsedSignature.params) + '\".');\n        }\n        parsedSignatures.push(parsedSignature);\n      });\n\n      // split and filter the types of the signatures, and then order them\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n      signatures.sort(compareSignatures);\n\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\n\n      // compile the tests\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\n\n      // compile the functions\n      var fns = signatures.map(function (signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn);\n      });\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1;\n\n      // simple and generic, but also slow\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(this, arguments);\n          }\n        }\n        return typed.onMismatch(name, arguments, signatures);\n      };\n\n      // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) {\n          return fn0.apply(fn, arguments);\n        }\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) {\n          return fn1.apply(fn, arguments);\n        }\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) {\n          return fn2.apply(fn, arguments);\n        }\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) {\n          return fn3.apply(fn, arguments);\n        }\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) {\n          return fn4.apply(fn, arguments);\n        }\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) {\n          return fn5.apply(fn, arguments);\n        }\n        return generic.apply(fn, arguments);\n      };\n\n      // attach name the typed function\n      try {\n        Object.defineProperty(fn, 'name', {\n          value: name\n        });\n      } catch (err) {\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\n        // so it's fine to have unnamed functions.\n      }\n\n      // attach signatures to the function\n      fn.signatures = createSignaturesMap(signatures);\n      return fn;\n    }\n\n    /**\n     * Action to take on mismatch\n     * @param {string} name      Name of function that was attempted to be called\n     * @param {Array} args       Actual arguments to the call\n     * @param {Array} signatures Known signatures of the named typed-function\n     */\n    function _onMismatch(name, args, signatures) {\n      throw createError(name, args, signatures);\n    }\n\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n    function trim(str) {\n      return str.trim();\n    }\n\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n    function notEmpty(str) {\n      return !!str;\n    }\n\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n    function notNull(value) {\n      return value !== null;\n    }\n\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n    function isInvalidParam(param) {\n      return param.types.length === 0;\n    }\n\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n    function uniq(arr) {\n      var entries = {};\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n      return Object.keys(entries);\n    }\n\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n    function getName(fns) {\n      var name = '';\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // check whether the names are the same when defined\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          } else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n      return name;\n    }\n\n    // extract and merge all signatures of a list with typed functions\n    function extractSignatures(fns) {\n      var err;\n      var signaturesMap = {};\n      function validateUnique(_signature, _fn) {\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\n          err = new Error('Signature \"' + _signature + '\" is defined twice');\n          err.data = {\n            signature: _signature\n          };\n          throw err;\n          // else: both signatures point to the same function, that's fine\n        }\n      }\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // test whether this is a typed-function\n        if (typeof fn.signatures === 'object') {\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              validateUnique(signature, fn.signatures[signature]);\n              signaturesMap[signature] = fn.signatures[signature];\n            }\n          }\n        } else if (typeof fn.signature === 'string') {\n          validateUnique(fn.signature, fn);\n          signaturesMap[fn.signature] = fn;\n        } else {\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\n          err.data = {\n            index: i\n          };\n          throw err;\n        }\n      }\n      return signaturesMap;\n    }\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function (signaturesMap) {\n        // find existing name\n        var fns = [];\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function (fns) {\n        return createTypedFunction(getName(fns), extractSignatures(fns));\n      },\n      'string, ...Function': function (name, fns) {\n        return createTypedFunction(name, extractSignatures(fns));\n      }\n    });\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.onMismatch = _onMismatch;\n    typed.throwMismatchError = _onMismatch;\n    typed.createError = createError;\n    typed.convert = convert;\n    typed.find = find;\n\n    /**\n     * add a type\n     * @param {{name: string, test: function}} type\n     * @param {boolean} [beforeObjectTest=true]\n     *                          If true, the new test will be inserted before\n     *                          the test with name 'Object' (if any), since\n     *                          tests for Object match Array and classes too.\n     */\n    typed.addType = function (type, beforeObjectTest) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n      if (beforeObjectTest !== false) {\n        for (var i = 0; i < typed.types.length; i++) {\n          if (typed.types[i].name === 'Object') {\n            typed.types.splice(i, 0, type);\n            return;\n          }\n        }\n      }\n      typed.types.push(type);\n    };\n\n    // add a conversion\n    typed.addConversion = function (conversion) {\n      if (!conversion || typeof conversion.from !== 'string' || typeof conversion.to !== 'string' || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n      typed.conversions.push(conversion);\n    };\n    return typed;\n  }\n  return create();\n});","map":{"version":3,"names":["root","factory","define","amd","exports","module","typed","ok","notOk","undef","undefined","create","_types","name","test","x","Array","isArray","Date","RegExp","constructor","Object","anyType","_ignore","_conversions","types","conversions","ignore","findTypeByName","typeName","entry","findInArray","hint","toLowerCase","TypeError","findTypeIndex","type","indexOf","findTypeName","value","find","fn","signature","signatures","arr","split","i","length","trim","str","join","match","convert","from","conversion","to","Error","stringifyParams","params","map","param","typeNames","getTypeName","restParam","parseParam","slice","filter","notEmpty","notIgnore","matchingConversions","filterConversions","exactTypes","typeIndex","conversionIndex","convertibleTypes","concat","parseSignature","index","array","parsedParam","SyntaxError","some","isInvalidParam","hasRestParam","last","hasConversions","compileTest","test0","test1","or","tests","compileTests","initial","varIndex","lastTest","testRestParam","args","testArgs","getParamAtIndex","getExpectedTypeNames","excludeConversions","isExactType","mergeExpectedParams","uniq","flatMap","createError","err","expected","_name","matchingSignatures","nextMatchingDefs","actualType","data","category","actual","lengths","Infinity","Math","min","apply","maxLength","max","expectedLength","getLowestTypeIndex","getLowestConversionIndex","compareParams","param1","param2","c","compareSignatures","signature1","signature2","len","matches","forEach","keys","compileArgsPreprocessing","fnConvert","compiledConversions","compileArgConversion","convertArgs","arguments","fnPreprocess","offset","preprocessRestParams","conversion0","conversion1","push","convertArg","arg","createSignaturesMap","signaturesMap","splitParams","ignoreConversionTypes","_splitParams","filteredTypes","typeGroups","typeGroup","splittedParams","hasConflictingParams","ii","typesNames1","typesNames2","hasOverlap","len1","len2","restParam1","restParam2","createTypedFunction","parsedSignatures","notNull","parsedSignature","conflictingSignature","s","sort","ok0","ok1","ok2","ok3","ok4","ok5","allOk","test00","test10","test20","test30","test40","test50","test01","test11","test21","test31","test41","test51","fns","fn0","fn1","fn2","fn3","fn4","fn5","len0","len3","len4","len5","iStart","iEnd","generic","onMismatch","arg0","arg1","defineProperty","_onMismatch","start","end","prototype","call","contains","item","array1","array2","entries","callback","getName","extractSignatures","validateUnique","_signature","_fn","hasOwnProperty","...Function","string, ...Function","throwMismatchError","addType","beforeObjectTest","splice","addConversion"],"sources":["/Users/poornima/Desktop/Google_Sheet/spreadsheet-app/node_modules/typed-function/typed-function.js"],"sourcesContent":["/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n}(this, function () {\n\n  function ok () {\n    return true;\n  }\n\n  function notOk () {\n    return false;\n  }\n\n  function undef () {\n    return undefined;\n  }\n\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n\n  // create a new instance of typed-function\n  function create () {\n    // data type tests\n    var _types = [\n      { name: 'number',    test: function (x) { return typeof x === 'number' } },\n      { name: 'string',    test: function (x) { return typeof x === 'string' } },\n      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },\n      { name: 'Function',  test: function (x) { return typeof x === 'function'} },\n      { name: 'Array',     test: Array.isArray },\n      { name: 'Date',      test: function (x) { return x instanceof Date } },\n      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },\n      { name: 'Object',    test: function (x) {\n        return typeof x === 'object' && x !== null && x.constructor === Object\n      }},\n      { name: 'null',      test: function (x) { return x === null } },\n      { name: 'undefined', test: function (x) { return x === undefined } }\n    ];\n\n    var anyType = {\n      name: 'any',\n      test: ok\n    }\n\n    // types which need to be ignored\n    var _ignore = [];\n\n    // type conversions\n    var _conversions = [];\n\n    // This is a temporary object, will be replaced with a typed function at the end\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n    function findTypeByName (typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n\n      if (entry) {\n        return entry;\n      }\n\n      if (typeName === 'any') { // special baked-in case 'any'\n        return anyType;\n      }\n\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n\n      throw new TypeError('Unknown type \"' + typeName + '\"' +\n          (hint ? ('. Did you mean \"' + hint.name + '\"?') : ''));\n    }\n\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n\n      return typed.types.indexOf(type);\n    }\n\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n\n      if (entry) {\n        return entry.name;\n      }\n\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n    function find (fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      }\n\n      // normalize input\n      var arr;\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      }\n      else if (Array.isArray(signature)) {\n        arr = signature;\n      }\n      else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n\n      var str = arr.join(',');\n\n      // find an exact match\n      var match = fn.signatures[str];\n      if (match) {\n        return match;\n      }\n\n      // TODO: extend find to match non-exact signatures\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n    function convert (value, type) {\n      var from = findTypeName(value);\n\n      // check conversion is needed\n      if (type === from) {\n        return value;\n      }\n\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n    \n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n    function stringifyParams (params) {\n      return params\n          .map(function (param) {\n            var typeNames = param.types.map(getTypeName);\n\n            return (param.restParam ? '...' : '') + typeNames.join('|');\n          })\n          .join(',');\n    }\n\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n    function parseParam (param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = (!restParam)\n          ? param\n          : (param.length > 3)\n              ? param.slice(3)\n              : 'any';\n\n      var typeNames = types.split('|').map(trim)\n          .filter(notEmpty)\n          .filter(notIgnore);\n\n      var matchingConversions = filterConversions(conversions, typeNames);\n\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n    function parseSignature (signature, fn, conversions) {\n      var params = [];\n\n      if (signature.trim() !== '') {\n        params = signature\n            .split(',')\n            .map(trim)\n            .map(function (param, index, array) {\n              var parsedParam = parseParam(param, conversions);\n\n              if (parsedParam.restParam && (index !== array.length - 1)) {\n                throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' +\n                    'only allowed for the last parameter');\n              }\n\n              return parsedParam;\n          });\n      }\n\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n    function hasRestParam(params) {\n      var param = last(params)\n      return param ? param.restParam : false;\n    }\n\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      }\n      else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      }\n      else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        }\n      }\n      else { // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        })\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n    function compileTests(params) {\n      var tests, test0, test1;\n\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n        var testRestParam = function (args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n          return testRestParam(args) && (args.length >= varIndex + 1);\n        };\n      }\n      else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        }\n        else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        }\n        else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        }\n        else { // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length\n          ? signature.params[index]\n          : hasRestParam(signature.params)\n              ? last(signature.params)\n              : null\n    }\n\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n    function getExpectedTypeNames (signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param\n          ? excludeConversions\n                  ? param.types.filter(isExactType)\n                  : param.types\n          : [];\n\n      return types.map(getTypeName);\n    }\n\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n    function getTypeName(type) {\n      return type.name;\n    }\n\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n\n      return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;\n    }\n\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n    function createError(name, args, signatures) {\n      var err, expected;\n      var _name = name || 'unnamed';\n\n      // test for wrong type at some index\n      var matchingSignatures = signatures;\n      var index;\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) &&\n              test(args[index]);\n        });\n\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n\n            err = new TypeError('Unexpected type of argument in function ' + _name +\n                ' (expected: ' + expected.join(' or ') +\n                ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            }\n            return err;\n          }\n        }\n        else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      }\n\n      // test for too few arguments\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name +\n            ' (expected: ' + expected.join(' or ') +\n            ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        }\n        return err;\n      }\n\n      // test for too many arguments\n      var maxLength = Math.max.apply(null, lengths);\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name +\n            ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        }\n        return err;\n      }\n\n      err = new TypeError('Arguments of type \"' + args.join(', ') +\n          '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      }\n      return err;\n    }\n\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n    function getLowestTypeIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n    function getLowestConversionIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareParams (param1, param2) {\n      var c;\n\n      // compare having a rest parameter or not\n      c = param1.restParam - param2.restParam;\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare having conversions or not\n      c = hasConversions(param1) - hasConversions(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of the types\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of any conversion\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareSignatures (signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c;\n\n      // compare whether the params have conversions at all or not\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions)\n      if (c !== 0) {\n        return c;\n      }\n\n      // next compare whether the params have conversions one by one\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the types of the params one by one\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the number of params\n      return signature1.params.length - signature2.params.length;\n    }\n\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 &&\n            typeNames.indexOf(conversion.to) !== -1 &&\n            !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn;\n\n      // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion)\n\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n\n          return fn.apply(this, args);\n        }\n      }\n\n      var fnPreprocess = fnConvert;\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n\n        fnPreprocess = function preprocessRestParams () {\n          return fnConvert.apply(this,\n              slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        }\n      }\n\n      return fnPreprocess;\n    }\n\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      });\n\n      // create optimized conversion functions depending on the number of conversions\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          }\n\n        case 1:\n          test0 = tests[0]\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            return arg;\n          }\n\n        case 2:\n          test0 = tests[0]\n          test1 = tests[1]\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            if (test1(arg)) {\n              return conversion1(arg)\n            }\n            return arg;\n          }\n\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n            return arg;\n          }\n      }\n    }\n\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n\n      return signaturesMap;\n    }\n\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index]\n          var filteredTypes = ignoreConversionTypes\n              ? param.types.filter(isExactType)\n              : param.types;\n          var typeGroups\n\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType)\n            typeGroups = exactTypes.length < filteredTypes.length\n                ? [exactTypes, filteredTypes]\n                : [filteredTypes]\n\n          }\n          else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type]\n            })\n          }\n\n          // recurse over the groups with types\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n\n        }\n        else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: (typeIndex === params.length - 1) && hasRestParam(params)\n            }\n          });\n\n          return [splittedParams];\n        }\n      }\n\n      return _splitParams(params, 0, []);\n    }\n\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n\n      return restParam1\n          ? restParam2 ? (len1 === len2) : (len2 >= len1)\n          : restParam2 ? (len1 >= len2)  : (len1 === len2)\n    }\n\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      }\n\n      // parse the signatures, and check for conflicts\n      var parsedSignatures = [];\n      Object.keys(signaturesMap)\n          .map(function (signature) {\n            return parseSignature(signature, signaturesMap[signature], typed.conversions);\n          })\n          .filter(notNull)\n          .forEach(function (parsedSignature) {\n            // check whether this parameter conflicts with already parsed signatures\n            var conflictingSignature = findInArray(parsedSignatures, function (s) {\n              return hasConflictingParams(s, parsedSignature)\n            });\n            if (conflictingSignature) {\n              throw new TypeError('Conflicting signatures \"' +\n                  stringifyParams(conflictingSignature.params) + '\" and \"' +\n                  stringifyParams(parsedSignature.params) + '\".');\n            }\n\n            parsedSignatures.push(parsedSignature);\n          });\n\n      // split and filter the types of the signatures, and then order them\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : []\n\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n\n      signatures.sort(compareSignatures);\n\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\n\n      // compile the tests\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\n\n      // compile the functions\n      var fns = signatures.map(function(signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn);\n      });\n\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1;\n\n      // simple and generic, but also slow\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(this, arguments);\n          }\n        }\n\n        return typed.onMismatch(name, arguments, signatures);\n      }\n\n      // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(fn, arguments); }\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(fn, arguments); }\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(fn, arguments); }\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(fn, arguments); }\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(fn, arguments); }\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(fn, arguments); }\n\n        return generic.apply(fn, arguments);\n      }\n\n      // attach name the typed function\n      try {\n        Object.defineProperty(fn, 'name', {value: name});\n      }\n      catch (err) {\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\n        // so it's fine to have unnamed functions.\n      }\n\n      // attach signatures to the function\n      fn.signatures = createSignaturesMap(signatures);\n\n      return fn;\n    }\n\n    /**\n     * Action to take on mismatch\n     * @param {string} name      Name of function that was attempted to be called\n     * @param {Array} args       Actual arguments to the call\n     * @param {Array} signatures Known signatures of the named typed-function\n     */\n    function _onMismatch(name, args, signatures) {\n      throw createError(name, args, signatures);\n    }\n\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n    function trim(str) {\n      return str.trim();\n    }\n\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n    function notEmpty(str) {\n      return !!str;\n    }\n\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n    function notNull(value) {\n      return value !== null;\n    }\n\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n    function isInvalidParam (param) {\n      return param.types.length === 0;\n    }\n\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n    function uniq(arr) {\n      var entries = {}\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n      return Object.keys(entries);\n    }\n\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n    function getName (fns) {\n      var name = '';\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // check whether the names are the same when defined\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          }\n          else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n\n      return name;\n    }\n\n    // extract and merge all signatures of a list with typed functions\n    function extractSignatures(fns) {\n      var err;\n      var signaturesMap = {};\n\n      function validateUnique(_signature, _fn) {\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\n          err = new Error('Signature \"' + _signature + '\" is defined twice');\n          err.data = {signature: _signature};\n          throw err;\n          // else: both signatures point to the same function, that's fine\n        }\n      }\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // test whether this is a typed-function\n        if (typeof fn.signatures === 'object') {\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              validateUnique(signature, fn.signatures[signature]);\n              signaturesMap[signature] = fn.signatures[signature];\n            }\n          }\n        }\n        else if (typeof fn.signature === 'string') {\n          validateUnique(fn.signature, fn);\n          signaturesMap[fn.signature] = fn;\n        }\n        else {\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\n          err.data = {index: i};\n          throw err;\n        }\n      }\n\n      return signaturesMap;\n    }\n\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function (signaturesMap) {\n        // find existing name\n        var fns = [];\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function (fns) {\n        return createTypedFunction(getName(fns), extractSignatures(fns));\n      },\n      'string, ...Function': function (name, fns) {\n        return createTypedFunction(name, extractSignatures(fns));\n      }\n    });\n\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.onMismatch = _onMismatch;\n    typed.throwMismatchError = _onMismatch;\n    typed.createError = createError;\n    typed.convert = convert;\n    typed.find = find;\n\n    /**\n     * add a type\n     * @param {{name: string, test: function}} type\n     * @param {boolean} [beforeObjectTest=true]\n     *                          If true, the new test will be inserted before\n     *                          the test with name 'Object' (if any), since\n     *                          tests for Object match Array and classes too.\n     */\n    typed.addType = function (type, beforeObjectTest) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      if (beforeObjectTest !== false) {\n        for (var i = 0; i < typed.types.length; i++) {\n          if (typed.types[i].name === 'Object') {\n            typed.types.splice(i, 0, type);\n            return\n          }\n        }\n      }\n\n      typed.types.push(type);\n    };\n\n    // add a conversion\n    typed.addConversion = function (conversion) {\n      if (!conversion\n          || typeof conversion.from !== 'string'\n          || typeof conversion.to !== 'string'\n          || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n\n      typed.conversions.push(conversion);\n    };\n\n    return typed;\n  }\n\n  return create();\n}));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}