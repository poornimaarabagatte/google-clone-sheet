{"ast":null,"code":"import { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { toSymbol } from '../../utils/latex.js';\nvar name = 'SymbolNode';\nvar dependencies = ['math', '?Unit', 'Node'];\nexport var createSymbolNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    math,\n    Unit,\n    Node\n  } = _ref;\n\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n  function isValuelessUnit(name) {\n    return Unit ? Unit.isValuelessUnit(name) : false;\n  }\n  /**\n   * @constructor SymbolNode\n   * @extends {Node}\n   * A symbol node can hold and resolve a symbol\n   * @param {string} name\n   * @extends {Node}\n   */\n\n  function SymbolNode(name) {\n    if (!(this instanceof SymbolNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    this.name = name;\n  }\n  SymbolNode.prototype = new Node();\n  SymbolNode.prototype.type = 'SymbolNode';\n  SymbolNode.prototype.isSymbolNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  SymbolNode.prototype._compile = function (math, argNames) {\n    var name = this.name;\n    if (argNames[name] === true) {\n      // this is a FunctionAssignment argument\n      // (like an x when inside the expression of a function assignment `f(x) = ...`)\n      return function (scope, args, context) {\n        return args[name];\n      };\n    } else if (name in math) {\n      return function (scope, args, context) {\n        return scope.has(name) ? scope.get(name) : getSafeProperty(math, name);\n      };\n    } else {\n      var isUnit = isValuelessUnit(name);\n      return function (scope, args, context) {\n        return scope.has(name) ? scope.get(name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  SymbolNode.prototype.forEach = function (callback) {// nothing to do, we don't have childs\n  };\n  /**\n   * Create a new SymbolNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {SymbolNode} Returns a clone of the node\n   */\n\n  SymbolNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n  /**\n   * Throws an error 'Undefined symbol {name}'\n   * @param {string} name\n   */\n\n  SymbolNode.onUndefinedSymbol = function (name) {\n    throw new Error('Undefined symbol ' + name);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {SymbolNode}\n   */\n\n  SymbolNode.prototype.clone = function () {\n    return new SymbolNode(this.name);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  SymbolNode.prototype._toString = function (options) {\n    return this.name;\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  SymbolNode.prototype.toHTML = function (options) {\n    var name = escape(this.name);\n    if (name === 'true' || name === 'false') {\n      return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n    } else if (name === 'i') {\n      return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n    } else if (name === 'Infinity') {\n      return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n    } else if (name === 'NaN') {\n      return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n    } else if (name === 'null') {\n      return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n    } else if (name === 'undefined') {\n      return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n    }\n    return '<span class=\"math-symbol\">' + name + '</span>';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  SymbolNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'SymbolNode',\n      name: this.name\n    };\n  };\n  /**\n   * Instantiate a SymbolNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\n   *                       where mathjs is optional\n   * @returns {SymbolNode}\n   */\n\n  SymbolNode.fromJSON = function (json) {\n    return new SymbolNode(json.name);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  SymbolNode.prototype._toTex = function (options) {\n    var isUnit = false;\n    if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n      isUnit = true;\n    }\n    var symbol = toSymbol(this.name, isUnit);\n    if (symbol[0] === '\\\\') {\n      // no space needed if the symbol starts with '\\'\n      return symbol;\n    } // the space prevents symbols from breaking stuff like '\\cdot' if it's written right before the symbol\n\n    return ' ' + symbol;\n  };\n  return SymbolNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["escape","getSafeProperty","factory","toSymbol","name","dependencies","createSymbolNode","_ref","math","Unit","Node","isValuelessUnit","SymbolNode","SyntaxError","TypeError","prototype","type","isSymbolNode","_compile","argNames","scope","args","context","has","get","isUnit","onUndefinedSymbol","forEach","callback","map","clone","Error","_toString","options","toHTML","toJSON","mathjs","fromJSON","json","_toTex","symbol","isClass","isNode"],"sources":["/Users/poornima/Desktop/Google_Sheet/spreadsheet-app/node_modules/mathjs/lib/esm/expression/node/SymbolNode.js"],"sourcesContent":["import { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { toSymbol } from '../../utils/latex.js';\nvar name = 'SymbolNode';\nvar dependencies = ['math', '?Unit', 'Node'];\nexport var createSymbolNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    math,\n    Unit,\n    Node\n  } = _ref;\n\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n  function isValuelessUnit(name) {\n    return Unit ? Unit.isValuelessUnit(name) : false;\n  }\n  /**\n   * @constructor SymbolNode\n   * @extends {Node}\n   * A symbol node can hold and resolve a symbol\n   * @param {string} name\n   * @extends {Node}\n   */\n\n\n  function SymbolNode(name) {\n    if (!(this instanceof SymbolNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    this.name = name;\n  }\n\n  SymbolNode.prototype = new Node();\n  SymbolNode.prototype.type = 'SymbolNode';\n  SymbolNode.prototype.isSymbolNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  SymbolNode.prototype._compile = function (math, argNames) {\n    var name = this.name;\n\n    if (argNames[name] === true) {\n      // this is a FunctionAssignment argument\n      // (like an x when inside the expression of a function assignment `f(x) = ...`)\n      return function (scope, args, context) {\n        return args[name];\n      };\n    } else if (name in math) {\n      return function (scope, args, context) {\n        return scope.has(name) ? scope.get(name) : getSafeProperty(math, name);\n      };\n    } else {\n      var isUnit = isValuelessUnit(name);\n      return function (scope, args, context) {\n        return scope.has(name) ? scope.get(name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  SymbolNode.prototype.forEach = function (callback) {// nothing to do, we don't have childs\n  };\n  /**\n   * Create a new SymbolNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {SymbolNode} Returns a clone of the node\n   */\n\n\n  SymbolNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n  /**\n   * Throws an error 'Undefined symbol {name}'\n   * @param {string} name\n   */\n\n\n  SymbolNode.onUndefinedSymbol = function (name) {\n    throw new Error('Undefined symbol ' + name);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {SymbolNode}\n   */\n\n\n  SymbolNode.prototype.clone = function () {\n    return new SymbolNode(this.name);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toString = function (options) {\n    return this.name;\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype.toHTML = function (options) {\n    var name = escape(this.name);\n\n    if (name === 'true' || name === 'false') {\n      return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n    } else if (name === 'i') {\n      return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n    } else if (name === 'Infinity') {\n      return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n    } else if (name === 'NaN') {\n      return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n    } else if (name === 'null') {\n      return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n    } else if (name === 'undefined') {\n      return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n    }\n\n    return '<span class=\"math-symbol\">' + name + '</span>';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  SymbolNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'SymbolNode',\n      name: this.name\n    };\n  };\n  /**\n   * Instantiate a SymbolNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\n   *                       where mathjs is optional\n   * @returns {SymbolNode}\n   */\n\n\n  SymbolNode.fromJSON = function (json) {\n    return new SymbolNode(json.name);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toTex = function (options) {\n    var isUnit = false;\n\n    if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n      isUnit = true;\n    }\n\n    var symbol = toSymbol(this.name, isUnit);\n\n    if (symbol[0] === '\\\\') {\n      // no space needed if the symbol starts with '\\'\n      return symbol;\n    } // the space prevents symbols from breaking stuff like '\\cdot' if it's written right before the symbol\n\n\n    return ' ' + symbol;\n  };\n\n  return SymbolNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}