{"ast":null,"code":"import { isConstantNode, isFunctionNode, isOperatorNode, isParenthesisNode, isSymbolNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'ParenthesisNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    ConstantNode,\n    OperatorNode,\n    FunctionNode,\n    ParenthesisNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n\n  function simplifyCore(node) {\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0]);\n      if (node.op === '+') {\n        // unary plus\n        return a0;\n      }\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0]);\n      var a1 = simplifyCore(node.args[1]);\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));\n          }\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op) {\n            var a00 = _a.args[0];\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n          return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n    } else if (isParenthesisNode(node)) {\n      var c = simplifyCore(node.content);\n      if (isParenthesisNode(c) || isSymbolNode(c) || isConstantNode(c)) {\n        return c;\n      }\n      return new ParenthesisNode(c);\n    } else if (isFunctionNode(node)) {\n      var args = node.args.map(simplifyCore).map(function (arg) {\n        return isParenthesisNode(arg) ? arg.content : arg;\n      });\n      return new FunctionNode(simplifyCore(node.fn), args);\n    } else {// cannot simplify\n    }\n    return node;\n  }\n  return simplifyCore;\n});","map":{"version":3,"names":["isConstantNode","isFunctionNode","isOperatorNode","isParenthesisNode","isSymbolNode","factory","name","dependencies","createSimplifyCore","_ref","equal","isZero","add","subtract","multiply","divide","pow","ConstantNode","OperatorNode","FunctionNode","ParenthesisNode","node0","node1","simplifyCore","node","isUnary","a0","args","op","isBinary","fn","_a","a1","value","a00","a00a1","implicit","a01","c","content","map","arg"],"sources":["/Users/poornima/Desktop/Google_Sheet/spreadsheet-app/node_modules/mathjs/lib/esm/function/algebra/simplify/simplifyCore.js"],"sourcesContent":["import { isConstantNode, isFunctionNode, isOperatorNode, isParenthesisNode, isSymbolNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'ParenthesisNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    ConstantNode,\n    OperatorNode,\n    FunctionNode,\n    ParenthesisNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n\n  function simplifyCore(node) {\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0]);\n\n      if (node.op === '+') {\n        // unary plus\n        return a0;\n      }\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0]);\n\n      var a1 = simplifyCore(node.args[1]);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n    } else if (isParenthesisNode(node)) {\n      var c = simplifyCore(node.content);\n\n      if (isParenthesisNode(c) || isSymbolNode(c) || isConstantNode(c)) {\n        return c;\n      }\n\n      return new ParenthesisNode(c);\n    } else if (isFunctionNode(node)) {\n      var args = node.args.map(simplifyCore).map(function (arg) {\n        return isParenthesisNode(arg) ? arg.content : arg;\n      });\n      return new FunctionNode(simplifyCore(node.fn), args);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}