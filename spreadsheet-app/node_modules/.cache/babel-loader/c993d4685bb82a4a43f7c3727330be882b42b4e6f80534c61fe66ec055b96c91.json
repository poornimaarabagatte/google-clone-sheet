{"ast":null,"code":"import { isOperatorNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { hasOwnProperty } from '../../../utils/object.js';\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nexport var createUtil = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n  var commutative = {\n    add: true,\n    multiply: true\n  };\n  var associative = {\n    add: true,\n    multiply: true\n  };\n  function isCommutative(node, context) {\n    if (!isOperatorNode(node)) {\n      return true;\n    }\n    var name = node.fn.toString();\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'commutative')) {\n      return context[name].commutative;\n    }\n    return commutative[name] || false;\n  }\n  function isAssociative(node, context) {\n    if (!isOperatorNode(node)) {\n      return false;\n    }\n    var name = node.fn.toString();\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'associative')) {\n      return context[name].associative;\n    }\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n    node.args = allChildren(node);\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n        if (isOperatorNode(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n      node.args = curnode.args;\n    }\n  }\n  function createMakeNodeFunction(node) {\n    if (isOperatorNode(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n  return {\n    createMakeNodeFunction,\n    isCommutative,\n    isAssociative,\n    flatten,\n    allChildren,\n    unflattenr,\n    unflattenl\n  };\n});","map":{"version":3,"names":["isOperatorNode","factory","hasOwnProperty","name","dependencies","createUtil","_ref","FunctionNode","OperatorNode","SymbolNode","commutative","add","multiply","associative","isCommutative","node","context","fn","toString","isAssociative","flatten","args","length","allChildren","i","op","children","findChildren","child","push","unflattenr","makeNode","createMakeNodeFunction","l","curnode","pop","unflattenl","shift","implicit","err","console","error"],"sources":["/Users/poornima/Desktop/Google_Sheet/spreadsheet-app/node_modules/mathjs/lib/esm/function/algebra/simplify/util.js"],"sourcesContent":["import { isOperatorNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { hasOwnProperty } from '../../../utils/object.js';\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nexport var createUtil = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n  var commutative = {\n    add: true,\n    multiply: true\n  };\n  var associative = {\n    add: true,\n    multiply: true\n  };\n\n  function isCommutative(node, context) {\n    if (!isOperatorNode(node)) {\n      return true;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'commutative')) {\n      return context[name].commutative;\n    }\n\n    return commutative[name] || false;\n  }\n\n  function isAssociative(node, context) {\n    if (!isOperatorNode(node)) {\n      return false;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'associative')) {\n      return context[name].associative;\n    }\n\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n\n    node.args = allChildren(node);\n\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n\n        if (isOperatorNode(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n\n  function createMakeNodeFunction(node) {\n    if (isOperatorNode(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n\n  return {\n    createMakeNodeFunction,\n    isCommutative,\n    isAssociative,\n    flatten,\n    allChildren,\n    unflattenr,\n    unflattenl\n  };\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}