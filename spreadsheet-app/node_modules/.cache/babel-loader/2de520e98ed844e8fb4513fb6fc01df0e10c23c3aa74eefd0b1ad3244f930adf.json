{"ast":null,"code":"import { isArray, isBigNumber, isCollection, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is.js';\nimport { isInteger } from '../../utils/number.js';\nimport { format } from '../../utils/string.js';\nimport { clone, deepStrictEqual } from '../../utils/object.js';\nimport { arraySize, getArrayDataType, processSizesWildcard, unsqueeze, validateIndex } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { DimensionError } from '../../error/DimensionError.js';\nvar name = 'SparseMatrix';\nvar dependencies = ['typed', 'equalScalar', 'Matrix'];\nexport var createSparseMatrixClass = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    equalScalar,\n    Matrix\n  } = _ref;\n\n  /**\n   * Sparse Matrix implementation. This type implements\n   * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))\n   * format for two-dimensional sparse matrices.\n   * @class SparseMatrix\n   */\n  function SparseMatrix(data, datatype) {\n    if (!(this instanceof SparseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n    if (isMatrix(data)) {\n      // create from matrix\n      _createFromMatrix(this, data, datatype);\n    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {\n      // initialize fields\n      this._values = data.values;\n      this._index = data.index;\n      this._ptr = data.ptr;\n      this._size = data.size;\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // create from array\n      _createFromArray(this, data, datatype);\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\n    } else {\n      // nothing provided\n      this._values = [];\n      this._index = [];\n      this._ptr = [0];\n      this._size = [0, 0];\n      this._datatype = datatype;\n    }\n  }\n  function _createFromMatrix(matrix, source, datatype) {\n    // check matrix type\n    if (source.type === 'SparseMatrix') {\n      // clone arrays\n      matrix._values = source._values ? clone(source._values) : undefined;\n      matrix._index = clone(source._index);\n      matrix._ptr = clone(source._ptr);\n      matrix._size = clone(source._size);\n      matrix._datatype = datatype || source._datatype;\n    } else {\n      // build from matrix data\n      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);\n    }\n  }\n  function _createFromArray(matrix, data, datatype) {\n    // initialize fields\n    matrix._values = [];\n    matrix._index = [];\n    matrix._ptr = [];\n    matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice\n\n    var rows = data.length;\n    var columns = 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n    if (isString(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    } // check we have rows (empty array)\n\n    if (rows > 0) {\n      // column index\n      var j = 0;\n      do {\n        // store pointer to values index\n        matrix._ptr.push(matrix._index.length); // loop rows\n\n        for (var i = 0; i < rows; i++) {\n          // current row\n          var row = data[i]; // check row is an array\n\n          if (isArray(row)) {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < row.length) {\n              columns = row.length;\n            } // check row has column\n\n            if (j < row.length) {\n              // value\n              var v = row[j]; // check value != 0\n\n              if (!eq(v, zero)) {\n                // store value\n                matrix._values.push(v); // index\n\n                matrix._index.push(i);\n              }\n            }\n          } else {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < 1) {\n              columns = 1;\n            } // check value != 0 (row is a scalar)\n\n            if (!eq(row, zero)) {\n              // store value\n              matrix._values.push(row); // index\n\n              matrix._index.push(i);\n            }\n          }\n        } // increment index\n\n        j++;\n      } while (j < columns);\n    } // store number of values in ptr\n\n    matrix._ptr.push(matrix._index.length); // size\n\n    matrix._size = [rows, columns];\n  }\n  SparseMatrix.prototype = new Matrix();\n  /**\n   * Create a new SparseMatrix\n   */\n\n  SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\n   * Attach type information\n   */\n\n  SparseMatrix.prototype.type = 'SparseMatrix';\n  SparseMatrix.prototype.isSparseMatrix = true;\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf SparseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n\n  SparseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._values, typeOf);\n  };\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()   // retrieve storage format\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The storage format.\n   */\n\n  SparseMatrix.prototype.storage = function () {\n    return 'sparse';\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()    // retrieve matrix datatype\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The datatype.\n   */\n\n  SparseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\n   * Create a new SparseMatrix\n   * @memberof SparseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n\n  SparseMatrix.prototype.create = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\n   * Get the matrix density.\n   *\n   * Usage:\n   *     const density = matrix.density()                   // retrieve matrix density\n   *\n   * @memberof SparseMatrix\n   * @return {number}           The matrix density.\n   */\n\n  SparseMatrix.prototype.density = function () {\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // calculate density\n\n    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof SparseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke subset on a Pattern only matrix');\n    } // check arguments\n\n    switch (arguments.length) {\n      case 1:\n        return _getsubset(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _setsubset(this, index, replacement, defaultValue);\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n  function _getsubset(matrix, idx) {\n    // check idx\n    if (!isIndex(idx)) {\n      throw new TypeError('Invalid index');\n    }\n    var isScalar = idx.isScalar();\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(idx.min());\n    } // validate dimensions\n\n    var size = idx.size();\n    if (size.length !== matrix._size.length) {\n      throw new DimensionError(size.length, matrix._size.length);\n    } // vars\n\n    var i, ii, k, kk; // validate if any of the ranges in the index is out of range\n\n    var min = idx.min();\n    var max = idx.max();\n    for (i = 0, ii = matrix._size.length; i < ii; i++) {\n      validateIndex(min[i], matrix._size[i]);\n      validateIndex(max[i], matrix._size[i]);\n    } // matrix arrays\n\n    var mvalues = matrix._values;\n    var mindex = matrix._index;\n    var mptr = matrix._ptr; // rows & columns dimensions for result matrix\n\n    var rows = idx.dimension(0);\n    var columns = idx.dimension(1); // workspace & permutation vector\n\n    var w = [];\n    var pv = []; // loop rows in resulting matrix\n\n    rows.forEach(function (i, r) {\n      // update permutation vector\n      pv[i] = r[0]; // mark i in workspace\n\n      w[i] = true;\n    }); // result matrix arrays\n\n    var values = mvalues ? [] : undefined;\n    var index = [];\n    var ptr = []; // loop columns in result matrix\n\n    columns.forEach(function (j) {\n      // update ptr\n      ptr.push(index.length); // loop values in column j\n\n      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {\n        // row\n        i = mindex[k]; // check row is in result matrix\n\n        if (w[i] === true) {\n          // push index\n          index.push(pv[i]); // check we need to process values\n\n          if (values) {\n            values.push(mvalues[k]);\n          }\n        }\n      }\n    }); // update ptr\n\n    ptr.push(index.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: size,\n      datatype: matrix._datatype\n    });\n  }\n  function _setsubset(matrix, index, submatrix, defaultValue) {\n    // check index\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n    if (isMatrix(submatrix)) {\n      // submatrix size\n      sSize = submatrix.size(); // use array representation\n\n      submatrix = submatrix.toArray();\n    } else {\n      // get submatrix size (array, scalar)\n      sSize = arraySize(submatrix);\n    } // check index is a scalar\n\n    if (isScalar) {\n      // verify submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      } // set value\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // validate dimensions, index size must be one or two dimensions\n      if (iSize.length !== 1 && iSize.length !== 2) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      } // check submatrix and index have the same dimensions\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n      if (!deepStrictEqual(iSize, sSize)) {\n        throw new DimensionError(iSize, sSize, '>');\n      } // offsets\n\n      var x0 = index.min()[0];\n      var y0 = index.min()[1]; // submatrix rows and columns\n\n      var m = sSize[0];\n      var n = sSize[1]; // loop submatrix\n\n      for (var x = 0; x < m; x++) {\n        // loop columns\n        for (var y = 0; y < n; y++) {\n          // value at i, j\n          var v = submatrix[x][y]; // invoke set (zero value will remove entry from matrix)\n\n          matrix.set([x + x0, y + y0], v, defaultValue);\n        }\n      }\n    }\n    return matrix;\n  }\n  /**\n   * Get a single element from the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n  SparseMatrix.prototype.get = function (index) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n    if (!this._values) {\n      throw new Error('Cannot invoke get on a Pattern only matrix');\n    } // row and column\n\n    var i = index[0];\n    var j = index[1]; // check i, j are valid\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[1]); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      return this._values[k];\n    }\n    return 0;\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} v\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be set to zero.\n   * @return {SparseMatrix} self\n   */\n\n  SparseMatrix.prototype.set = function (index, v, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n    if (!this._values) {\n      throw new Error('Cannot invoke set on a Pattern only matrix');\n    } // row and column\n\n    var i = index[0];\n    var j = index[1]; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n    if (isString(this._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, this._datatype);\n    } // check we need to resize matrix\n\n    if (i > rows - 1 || j > columns - 1) {\n      // resize matrix\n      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns\n\n      rows = this._size[0];\n      columns = this._size[1];\n    } // check i, j are valid\n\n    validateIndex(i, rows);\n    validateIndex(j, columns); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      // check value != 0\n      if (!eq(v, zero)) {\n        // update value\n        this._values[k] = v;\n      } else {\n        // remove value from matrix\n        _remove(k, j, this._values, this._index, this._ptr);\n      }\n    } else {\n      // insert value @ (i, j)\n      _insert(k, i, j, v, this._values, this._index, this._ptr);\n    }\n    return this;\n  };\n  function _getValueIndex(i, top, bottom, index) {\n    // check row is on the bottom side\n    if (bottom - top === 0) {\n      return bottom;\n    } // loop rows [top, bottom[\n\n    for (var r = top; r < bottom; r++) {\n      // check we found value index\n      if (index[r] === i) {\n        return r;\n      }\n    } // we did not find row\n\n    return top;\n  }\n  function _remove(k, j, values, index, ptr) {\n    // remove value @ k\n    values.splice(k, 1);\n    index.splice(k, 1); // update pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]--;\n    }\n  }\n  function _insert(k, i, j, v, values, index, ptr) {\n    // insert value\n    values.splice(k, 0, v); // update row for k\n\n    index.splice(k, 0, i); // update column pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]++;\n    }\n  }\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof SparseMatrix\n   * @param {number[] | Matrix} size  The new size the matrix should have.\n   *                                  Since sparse matrices are always two-dimensional,\n   *                                  size must be two numbers in either an array or a matrix\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isCollection(size)) {\n      throw new TypeError('Array or Matrix expected');\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n\n    var sizeArray = size.valueOf().map(value => {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    });\n    if (sizeArray.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // check sizes\n\n    sizeArray.forEach(function (value) {\n      if (!isNumber(value) || !isInteger(value) || value < 0) {\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(sizeArray) + ')');\n      }\n    }); // matrix to resize\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, sizeArray[0], sizeArray[1], defaultValue);\n  };\n  function _resize(matrix, rows, columns, defaultValue) {\n    // value to insert at the time of growing matrix\n    var value = defaultValue || 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n    if (isString(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype); // convert value to the same datatype\n\n      value = typed.convert(value, matrix._datatype);\n    } // should we insert the value?\n\n    var ins = !eq(value, zero); // old columns and rows\n\n    var r = matrix._size[0];\n    var c = matrix._size[1];\n    var i, j, k; // check we need to increase columns\n\n    if (columns > c) {\n      // loop new columns\n      for (j = c; j < columns; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values\n\n        if (ins) {\n          // loop rows\n          for (i = 0; i < r; i++) {\n            // add new matrix._values\n            matrix._values.push(value); // update matrix._index\n\n            matrix._index.push(i);\n          }\n        }\n      } // store number of matrix._values in matrix._ptr\n\n      matrix._ptr[columns] = matrix._values.length;\n    } else if (columns < c) {\n      // truncate matrix._ptr\n      matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index\n\n      matrix._values.splice(matrix._ptr[columns], matrix._values.length);\n      matrix._index.splice(matrix._ptr[columns], matrix._index.length);\n    } // update columns\n\n    c = columns; // check we need to increase rows\n\n    if (rows > r) {\n      // check we have to insert values\n      if (ins) {\n        // inserts\n        var n = 0; // loop columns\n\n        for (j = 0; j < c; j++) {\n          // update matrix._ptr for current column\n          matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values\n\n          k = matrix._ptr[j + 1] + n; // pointer\n\n          var p = 0; // loop new rows, initialize pointer\n\n          for (i = r; i < rows; i++, p++) {\n            // add value\n            matrix._values.splice(k + p, 0, value); // update matrix._index\n\n            matrix._index.splice(k + p, 0, i); // increment inserts\n\n            n++;\n          }\n        } // store number of matrix._values in matrix._ptr\n\n        matrix._ptr[c] = matrix._values.length;\n      }\n    } else if (rows < r) {\n      // deletes\n      var d = 0; // loop columns\n\n      for (j = 0; j < c; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column\n\n        var k0 = matrix._ptr[j];\n        var k1 = matrix._ptr[j + 1] - d; // loop matrix._index\n\n        for (k = k0; k < k1; k++) {\n          // row\n          i = matrix._index[k]; // check we need to delete value and matrix._index\n\n          if (i > rows - 1) {\n            // remove value\n            matrix._values.splice(k, 1); // remove item from matrix._index\n\n            matrix._index.splice(k, 1); // increase deletes\n\n            d++;\n          }\n        }\n      } // update matrix._ptr for current column\n\n      matrix._ptr[j] = matrix._values.length;\n    } // update matrix._size\n\n    matrix._size[0] = rows;\n    matrix._size[1] = columns; // return matrix\n\n    return matrix;\n  }\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof SparseMatrix\n   * @param {number[]} sizes          The new size the matrix should have.\n   *                                  Since sparse matrices are always two-dimensional,\n   *                                  size must be two numbers in either an array or a matrix\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n  SparseMatrix.prototype.reshape = function (sizes, copy) {\n    // validate arguments\n    if (!isArray(sizes)) {\n      throw new TypeError('Array expected');\n    }\n    if (sizes.length !== 2) {\n      throw new Error('Sparse matrices can only be reshaped in two dimensions');\n    } // check sizes\n\n    sizes.forEach(function (value) {\n      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {\n        throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + format(sizes) + ')');\n      }\n    });\n    var currentLength = this._size[0] * this._size[1];\n    sizes = processSizesWildcard(sizes, currentLength);\n    var newLength = sizes[0] * sizes[1]; // m * n must not change\n\n    if (currentLength !== newLength) {\n      throw new Error('Reshaping sparse matrix will result in the wrong number of elements');\n    } // matrix to reshape\n\n    var m = copy ? this.clone() : this; // return unchanged if the same shape\n\n    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {\n      return m;\n    } // Convert to COO format (generate a column index)\n\n    var colIndex = [];\n    for (var i = 0; i < m._ptr.length; i++) {\n      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {\n        colIndex.push(i);\n      }\n    } // Clone the values array\n\n    var values = m._values.slice(); // Clone the row index array\n\n    var rowIndex = m._index.slice(); // Transform the (row, column) indices\n\n    for (var _i = 0; _i < m._index.length; _i++) {\n      var r1 = rowIndex[_i];\n      var c1 = colIndex[_i];\n      var flat = r1 * m._size[1] + c1;\n      colIndex[_i] = flat % sizes[1];\n      rowIndex[_i] = Math.floor(flat / sizes[1]);\n    } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored\n    // in column-major order, so we have to reorder the value array now. One option is to use a multisort,\n    // sorting several arrays based on some other array.\n    // OR, we could easily just:\n    // 1. Remove all values from the matrix\n\n    m._values.length = 0;\n    m._index.length = 0;\n    m._ptr.length = sizes[1] + 1;\n    m._size = sizes.slice();\n    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {\n      m._ptr[_i2] = 0;\n    } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)\n    // This step is probably the most time-consuming\n\n    for (var h = 0; h < values.length; h++) {\n      var _i3 = rowIndex[h];\n      var _j = colIndex[h];\n      var v = values[h];\n      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);\n      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);\n    } // The value indices are inserted out of order, but apparently that's... still OK?\n\n    return m;\n  };\n  /**\n   * Create a clone of the matrix\n   * @memberof SparseMatrix\n   * @return {SparseMatrix} clone\n   */\n\n  SparseMatrix.prototype.clone = function () {\n    var m = new SparseMatrix({\n      values: this._values ? clone(this._values) : undefined,\n      index: clone(this._index),\n      ptr: clone(this._ptr),\n      size: clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof SparseMatrix\n   * @returns {number[]} size\n   */\n\n  SparseMatrix.prototype.size = function () {\n    return this._size.slice(0); // copy the Array\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *\n   * @return {SparseMatrix} matrix\n   */\n\n  SparseMatrix.prototype.map = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke map on a Pattern only matrix');\n    } // matrix instance\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // invoke callback\n\n    var invoke = function invoke(v, i, j) {\n      // invoke callback\n      return callback(v, [i, j], me);\n    }; // invoke _map\n\n    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on the interval\n   * [minRow..maxRow, minColumn..maxColumn].\n   */\n\n  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {\n    // result arrays\n    var values = [];\n    var index = [];\n    var ptr = []; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n    if (isString(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype);\n    } // invoke callback\n\n    var invoke = function invoke(v, x, y) {\n      // invoke callback\n      v = callback(v, x, y); // check value != 0\n\n      if (!eq(v, zero)) {\n        // store value\n        values.push(v); // index\n\n        index.push(x);\n      }\n    }; // loop columns\n\n    for (var j = minColumn; j <= maxColumn; j++) {\n      // store pointer to values index\n      ptr.push(values.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = matrix._ptr[j];\n      var k1 = matrix._ptr[j + 1];\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = matrix._index[k]; // check i is in range\n\n          if (i >= minRow && i <= maxRow) {\n            // value @ k\n            invoke(matrix._values[k], i - minRow, j - minColumn);\n          }\n        }\n      } else {\n        // create a cache holding all defined values\n        var _values = {};\n        for (var _k = k0; _k < k1; _k++) {\n          var _i4 = matrix._index[_k];\n          _values[_i4] = matrix._values[_k];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {\n          var value = _i5 in _values ? _values[_i5] : 0;\n          invoke(value, _i5 - minRow, j - minColumn);\n        }\n      }\n    } // store number of values in ptr\n\n    ptr.push(values.length); // return sparse matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]\n    });\n  }\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *                              If false, the indices are guaranteed to be in order,\n   *                              if true, the indices can be unordered.\n   */\n\n  SparseMatrix.prototype.forEach = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke forEach on a Pattern only matrix');\n    } // matrix instance\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = this._index[k]; // value @ k\n\n          callback(this._values[k], [i, j], me);\n        }\n      } else {\n        // create a cache holding all defined values\n        var values = {};\n        for (var _k2 = k0; _k2 < k1; _k2++) {\n          var _i6 = this._index[_k2];\n          values[_i6] = this._values[_k2];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n        for (var _i7 = 0; _i7 < rows; _i7++) {\n          var value = _i7 in values ? values[_i7] : 0;\n          callback(value, [_i7, j], me);\n        }\n      }\n    }\n  };\n  /**\n   * Iterate over the matrix elements, skipping zeros\n   * @return {Iterable<{ value, index: number[] }>}\n   */\n\n  SparseMatrix.prototype[Symbol.iterator] = function* () {\n    if (!this._values) {\n      throw new Error('Cannot iterate a Pattern only matrix');\n    }\n    var columns = this._size[1];\n    for (var j = 0; j < columns; j++) {\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n      for (var k = k0; k < k1; k++) {\n        // row index\n        var i = this._index[k];\n        yield {\n          value: this._values[k],\n          index: [i, j]\n        };\n      }\n    }\n  };\n  /**\n   * Create an Array with a copy of the data of the SparseMatrix\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n\n  SparseMatrix.prototype.toArray = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, true);\n  };\n  /**\n   * Get the primitive value of the SparseMatrix: a two dimensions array\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n\n  SparseMatrix.prototype.valueOf = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, false);\n  };\n  function _toArray(values, index, ptr, size, copy) {\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1]; // result\n\n    var a = []; // vars\n\n    var i, j; // initialize array\n\n    for (i = 0; i < rows; i++) {\n      a[i] = [];\n      for (j = 0; j < columns; j++) {\n        a[i][j] = 0;\n      }\n    } // loop columns\n\n    for (j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        i = index[k]; // set value (use one for pattern matrix)\n\n        a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;\n      }\n    }\n    return a;\n  }\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof SparseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n  SparseMatrix.prototype.format = function (options) {\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // density\n\n    var density = this.density(); // rows & columns\n\n    var str = 'Sparse Matrix [' + format(rows, options) + ' x ' + format(columns, options) + '] density: ' + format(density, options) + '\\n'; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        var i = this._index[k]; // append value\n\n        str += '\\n    (' + format(i, options) + ', ' + format(j, options) + ') ==> ' + (this._values ? format(this._values[k], options) : 'X');\n      }\n    }\n    return str;\n  };\n  /**\n   * Get a string representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {string} str\n   */\n\n  SparseMatrix.prototype.toString = function () {\n    return format(this.toArray());\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {Object}\n   */\n\n  SparseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'SparseMatrix',\n      values: this._values,\n      index: this._index,\n      ptr: this._ptr,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof SparseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix vector with the diagonal values.\n   */\n\n  SparseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays\n\n    var values = [];\n    var index = [];\n    var ptr = []; // initial ptr value\n\n    ptr[0] = 0; // loop columns\n\n    for (var j = kSuper; j < columns && values.length < n; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop x within [k0, k1[\n\n      for (var x = k0; x < k1; x++) {\n        // row index\n        var i = this._index[x]; // check row\n\n        if (i === j - kSuper + kSub) {\n          // value on this column\n          values.push(this._values[x]); // store row\n\n          index[values.length - 1] = i - kSub; // exit loop\n\n          break;\n        }\n      }\n    } // close ptr\n\n    ptr.push(values.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [n, 1]\n    });\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof SparseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SparseMatrix\", \"values\": [], \"index\": [], \"ptr\": [], \"size\": []}`,\n   *                       where mathjs is optional\n   * @returns {SparseMatrix}\n   */\n\n  SparseMatrix.fromJSON = function (json) {\n    return new SparseMatrix(json);\n  };\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {Array} size                       The matrix size.\n   * @param {number | Array | Matrix } value   The values for the diagonal.\n   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]            The default value for non-diagonal\n   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.\n   *\n   * @returns {SparseMatrix}\n   */\n\n  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if (isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    } // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n    if (isString(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (isMatrix(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // create arrays\n\n    var values = [];\n    var index = [];\n    var ptr = []; // loop items\n\n    for (var j = 0; j < columns; j++) {\n      // number of rows with value\n      ptr.push(values.length); // diagonal index\n\n      var i = j - kSuper; // check we need to set diagonal value\n\n      if (i >= 0 && i < n) {\n        // get value @ i\n        var v = _value(i); // check for zero\n\n        if (!eq(v, zero)) {\n          // column\n          index.push(i + kSub); // add value\n\n          values.push(v);\n        }\n      }\n    } // last value should be number of values\n\n    ptr.push(values.length); // create SparseMatrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [rows, columns]\n    });\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n  SparseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]); // swap rows\n\n    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance\n\n    return this;\n  };\n  /**\n   * Loop rows with data in column j.\n   *\n   * @param {number} j            Column\n   * @param {Array} values        Matrix values\n   * @param {Array} index         Matrix row indeces\n   * @param {Array} ptr           Matrix column pointers\n   * @param {Function} callback   Callback function invoked for every row in column j\n   */\n\n  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {\n    // indeces for column j\n    var k0 = ptr[j];\n    var k1 = ptr[j + 1]; // loop\n\n    for (var k = k0; k < k1; k++) {\n      // invoke callback\n      callback(index[k], values[k]);\n    }\n  };\n  /**\n   * Swap rows x and y in Sparse Matrix data structures.\n   *\n   * @param {number} x         Matrix row index 1\n   * @param {number} y         Matrix row index 2\n   * @param {number} columns   Number of columns in matrix\n   * @param {Array} values     Matrix values\n   * @param {Array} index      Matrix row indeces\n   * @param {Array} ptr        Matrix column pointers\n   */\n\n  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // find value index @ x\n\n      var kx = _getValueIndex(x, k0, k1, index); // find value index @ x\n\n      var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix\n\n      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {\n        // swap values (check for pattern matrix)\n        if (values) {\n          var v = values[kx];\n          values[kx] = values[ky];\n          values[ky] = v;\n        } // next column\n\n        continue;\n      } // check x row exist & no y row\n\n      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {\n        // value @ x (check for pattern matrix)\n        var vx = values ? values[kx] : undefined; // insert value @ y\n\n        index.splice(ky, 0, y);\n        if (values) {\n          values.splice(ky, 0, vx);\n        } // remove value @ x (adjust array index if needed)\n\n        index.splice(ky <= kx ? kx + 1 : kx, 1);\n        if (values) {\n          values.splice(ky <= kx ? kx + 1 : kx, 1);\n        } // next column\n\n        continue;\n      } // check y row exist & no x row\n\n      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {\n        // value @ y (check for pattern matrix)\n        var vy = values ? values[ky] : undefined; // insert value @ x\n\n        index.splice(kx, 0, x);\n        if (values) {\n          values.splice(kx, 0, vy);\n        } // remove value @ y (adjust array index if needed)\n\n        index.splice(kx <= ky ? ky + 1 : ky, 1);\n        if (values) {\n          values.splice(kx <= ky ? ky + 1 : ky, 1);\n        }\n      }\n    }\n  };\n  return SparseMatrix;\n}, {\n  isClass: true\n});","map":{"version":3,"names":["isArray","isBigNumber","isCollection","isIndex","isMatrix","isNumber","isString","typeOf","isInteger","format","clone","deepStrictEqual","arraySize","getArrayDataType","processSizesWildcard","unsqueeze","validateIndex","factory","DimensionError","name","dependencies","createSparseMatrixClass","_ref","typed","equalScalar","Matrix","SparseMatrix","data","datatype","SyntaxError","Error","_createFromMatrix","index","ptr","size","_values","values","_index","_ptr","_size","_datatype","_createFromArray","TypeError","matrix","source","type","undefined","valueOf","rows","length","columns","eq","zero","find","convert","j","push","i","row","v","prototype","createSparseMatrix","isSparseMatrix","getDataType","storage","create","density","subset","replacement","defaultValue","arguments","_getsubset","_setsubset","idx","isScalar","get","min","ii","k","kk","max","mvalues","mindex","mptr","dimension","w","pv","forEach","r","submatrix","iSize","sSize","toArray","set","outer","x0","y0","m","n","x","y","_getValueIndex","_resize","Math","_remove","_insert","top","bottom","splice","resize","copy","sizeArray","map","value","Array","ins","c","p","d","k0","k1","reshape","sizes","currentLength","newLength","colIndex","slice","rowIndex","_i","r1","c1","flat","floor","_i2","h","_i3","_j","callback","skipZeros","me","invoke","_map","minRow","maxRow","minColumn","maxColumn","_k","_i4","_i5","_k2","_i6","_i7","Symbol","iterator","_toArray","a","options","str","toString","toJSON","mathjs","diagonal","toNumber","kSuper","kSub","fromJSON","json","s","_value","ms","swapRows","_swapRows","_forEachRow","kx","ky","vx","vy","isClass"],"sources":["/Users/poornima/Desktop/Google_Sheet/spreadsheet-app/node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js"],"sourcesContent":["import { isArray, isBigNumber, isCollection, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is.js';\nimport { isInteger } from '../../utils/number.js';\nimport { format } from '../../utils/string.js';\nimport { clone, deepStrictEqual } from '../../utils/object.js';\nimport { arraySize, getArrayDataType, processSizesWildcard, unsqueeze, validateIndex } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { DimensionError } from '../../error/DimensionError.js';\nvar name = 'SparseMatrix';\nvar dependencies = ['typed', 'equalScalar', 'Matrix'];\nexport var createSparseMatrixClass = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    equalScalar,\n    Matrix\n  } = _ref;\n\n  /**\n   * Sparse Matrix implementation. This type implements\n   * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))\n   * format for two-dimensional sparse matrices.\n   * @class SparseMatrix\n   */\n  function SparseMatrix(data, datatype) {\n    if (!(this instanceof SparseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if (isMatrix(data)) {\n      // create from matrix\n      _createFromMatrix(this, data, datatype);\n    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {\n      // initialize fields\n      this._values = data.values;\n      this._index = data.index;\n      this._ptr = data.ptr;\n      this._size = data.size;\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // create from array\n      _createFromArray(this, data, datatype);\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\n    } else {\n      // nothing provided\n      this._values = [];\n      this._index = [];\n      this._ptr = [0];\n      this._size = [0, 0];\n      this._datatype = datatype;\n    }\n  }\n\n  function _createFromMatrix(matrix, source, datatype) {\n    // check matrix type\n    if (source.type === 'SparseMatrix') {\n      // clone arrays\n      matrix._values = source._values ? clone(source._values) : undefined;\n      matrix._index = clone(source._index);\n      matrix._ptr = clone(source._ptr);\n      matrix._size = clone(source._size);\n      matrix._datatype = datatype || source._datatype;\n    } else {\n      // build from matrix data\n      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);\n    }\n  }\n\n  function _createFromArray(matrix, data, datatype) {\n    // initialize fields\n    matrix._values = [];\n    matrix._index = [];\n    matrix._ptr = [];\n    matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice\n\n    var rows = data.length;\n    var columns = 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    } // check we have rows (empty array)\n\n\n    if (rows > 0) {\n      // column index\n      var j = 0;\n\n      do {\n        // store pointer to values index\n        matrix._ptr.push(matrix._index.length); // loop rows\n\n\n        for (var i = 0; i < rows; i++) {\n          // current row\n          var row = data[i]; // check row is an array\n\n          if (isArray(row)) {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < row.length) {\n              columns = row.length;\n            } // check row has column\n\n\n            if (j < row.length) {\n              // value\n              var v = row[j]; // check value != 0\n\n              if (!eq(v, zero)) {\n                // store value\n                matrix._values.push(v); // index\n\n\n                matrix._index.push(i);\n              }\n            }\n          } else {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < 1) {\n              columns = 1;\n            } // check value != 0 (row is a scalar)\n\n\n            if (!eq(row, zero)) {\n              // store value\n              matrix._values.push(row); // index\n\n\n              matrix._index.push(i);\n            }\n          }\n        } // increment index\n\n\n        j++;\n      } while (j < columns);\n    } // store number of values in ptr\n\n\n    matrix._ptr.push(matrix._index.length); // size\n\n\n    matrix._size = [rows, columns];\n  }\n\n  SparseMatrix.prototype = new Matrix();\n  /**\n   * Create a new SparseMatrix\n   */\n\n  SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\n   * Attach type information\n   */\n\n\n  SparseMatrix.prototype.type = 'SparseMatrix';\n  SparseMatrix.prototype.isSparseMatrix = true;\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf SparseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n\n  SparseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._values, typeOf);\n  };\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()   // retrieve storage format\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The storage format.\n   */\n\n\n  SparseMatrix.prototype.storage = function () {\n    return 'sparse';\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()    // retrieve matrix datatype\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The datatype.\n   */\n\n\n  SparseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\n   * Create a new SparseMatrix\n   * @memberof SparseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n\n\n  SparseMatrix.prototype.create = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\n   * Get the matrix density.\n   *\n   * Usage:\n   *     const density = matrix.density()                   // retrieve matrix density\n   *\n   * @memberof SparseMatrix\n   * @return {number}           The matrix density.\n   */\n\n\n  SparseMatrix.prototype.density = function () {\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // calculate density\n\n    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof SparseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n\n  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke subset on a Pattern only matrix');\n    } // check arguments\n\n\n    switch (arguments.length) {\n      case 1:\n        return _getsubset(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _setsubset(this, index, replacement, defaultValue);\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n\n  function _getsubset(matrix, idx) {\n    // check idx\n    if (!isIndex(idx)) {\n      throw new TypeError('Invalid index');\n    }\n\n    var isScalar = idx.isScalar();\n\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(idx.min());\n    } // validate dimensions\n\n\n    var size = idx.size();\n\n    if (size.length !== matrix._size.length) {\n      throw new DimensionError(size.length, matrix._size.length);\n    } // vars\n\n\n    var i, ii, k, kk; // validate if any of the ranges in the index is out of range\n\n    var min = idx.min();\n    var max = idx.max();\n\n    for (i = 0, ii = matrix._size.length; i < ii; i++) {\n      validateIndex(min[i], matrix._size[i]);\n      validateIndex(max[i], matrix._size[i]);\n    } // matrix arrays\n\n\n    var mvalues = matrix._values;\n    var mindex = matrix._index;\n    var mptr = matrix._ptr; // rows & columns dimensions for result matrix\n\n    var rows = idx.dimension(0);\n    var columns = idx.dimension(1); // workspace & permutation vector\n\n    var w = [];\n    var pv = []; // loop rows in resulting matrix\n\n    rows.forEach(function (i, r) {\n      // update permutation vector\n      pv[i] = r[0]; // mark i in workspace\n\n      w[i] = true;\n    }); // result matrix arrays\n\n    var values = mvalues ? [] : undefined;\n    var index = [];\n    var ptr = []; // loop columns in result matrix\n\n    columns.forEach(function (j) {\n      // update ptr\n      ptr.push(index.length); // loop values in column j\n\n      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {\n        // row\n        i = mindex[k]; // check row is in result matrix\n\n        if (w[i] === true) {\n          // push index\n          index.push(pv[i]); // check we need to process values\n\n          if (values) {\n            values.push(mvalues[k]);\n          }\n        }\n      }\n    }); // update ptr\n\n    ptr.push(index.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: size,\n      datatype: matrix._datatype\n    });\n  }\n\n  function _setsubset(matrix, index, submatrix, defaultValue) {\n    // check index\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n\n    if (isMatrix(submatrix)) {\n      // submatrix size\n      sSize = submatrix.size(); // use array representation\n\n      submatrix = submatrix.toArray();\n    } else {\n      // get submatrix size (array, scalar)\n      sSize = arraySize(submatrix);\n    } // check index is a scalar\n\n\n    if (isScalar) {\n      // verify submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      } // set value\n\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // validate dimensions, index size must be one or two dimensions\n      if (iSize.length !== 1 && iSize.length !== 2) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      } // check submatrix and index have the same dimensions\n\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n\n      if (!deepStrictEqual(iSize, sSize)) {\n        throw new DimensionError(iSize, sSize, '>');\n      } // offsets\n\n\n      var x0 = index.min()[0];\n      var y0 = index.min()[1]; // submatrix rows and columns\n\n      var m = sSize[0];\n      var n = sSize[1]; // loop submatrix\n\n      for (var x = 0; x < m; x++) {\n        // loop columns\n        for (var y = 0; y < n; y++) {\n          // value at i, j\n          var v = submatrix[x][y]; // invoke set (zero value will remove entry from matrix)\n\n          matrix.set([x + x0, y + y0], v, defaultValue);\n        }\n      }\n    }\n\n    return matrix;\n  }\n  /**\n   * Get a single element from the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n\n  SparseMatrix.prototype.get = function (index) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n\n    if (!this._values) {\n      throw new Error('Cannot invoke get on a Pattern only matrix');\n    } // row and column\n\n\n    var i = index[0];\n    var j = index[1]; // check i, j are valid\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[1]); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      return this._values[k];\n    }\n\n    return 0;\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} v\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be set to zero.\n   * @return {SparseMatrix} self\n   */\n\n\n  SparseMatrix.prototype.set = function (index, v, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n\n    if (!this._values) {\n      throw new Error('Cannot invoke set on a Pattern only matrix');\n    } // row and column\n\n\n    var i = index[0];\n    var j = index[1]; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(this._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, this._datatype);\n    } // check we need to resize matrix\n\n\n    if (i > rows - 1 || j > columns - 1) {\n      // resize matrix\n      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns\n\n\n      rows = this._size[0];\n      columns = this._size[1];\n    } // check i, j are valid\n\n\n    validateIndex(i, rows);\n    validateIndex(j, columns); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      // check value != 0\n      if (!eq(v, zero)) {\n        // update value\n        this._values[k] = v;\n      } else {\n        // remove value from matrix\n        _remove(k, j, this._values, this._index, this._ptr);\n      }\n    } else {\n      // insert value @ (i, j)\n      _insert(k, i, j, v, this._values, this._index, this._ptr);\n    }\n\n    return this;\n  };\n\n  function _getValueIndex(i, top, bottom, index) {\n    // check row is on the bottom side\n    if (bottom - top === 0) {\n      return bottom;\n    } // loop rows [top, bottom[\n\n\n    for (var r = top; r < bottom; r++) {\n      // check we found value index\n      if (index[r] === i) {\n        return r;\n      }\n    } // we did not find row\n\n\n    return top;\n  }\n\n  function _remove(k, j, values, index, ptr) {\n    // remove value @ k\n    values.splice(k, 1);\n    index.splice(k, 1); // update pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]--;\n    }\n  }\n\n  function _insert(k, i, j, v, values, index, ptr) {\n    // insert value\n    values.splice(k, 0, v); // update row for k\n\n    index.splice(k, 0, i); // update column pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]++;\n    }\n  }\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof SparseMatrix\n   * @param {number[] | Matrix} size  The new size the matrix should have.\n   *                                  Since sparse matrices are always two-dimensional,\n   *                                  size must be two numbers in either an array or a matrix\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n\n  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isCollection(size)) {\n      throw new TypeError('Array or Matrix expected');\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n\n\n    var sizeArray = size.valueOf().map(value => {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    });\n\n    if (sizeArray.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // check sizes\n\n\n    sizeArray.forEach(function (value) {\n      if (!isNumber(value) || !isInteger(value) || value < 0) {\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(sizeArray) + ')');\n      }\n    }); // matrix to resize\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, sizeArray[0], sizeArray[1], defaultValue);\n  };\n\n  function _resize(matrix, rows, columns, defaultValue) {\n    // value to insert at the time of growing matrix\n    var value = defaultValue || 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype); // convert value to the same datatype\n\n      value = typed.convert(value, matrix._datatype);\n    } // should we insert the value?\n\n\n    var ins = !eq(value, zero); // old columns and rows\n\n    var r = matrix._size[0];\n    var c = matrix._size[1];\n    var i, j, k; // check we need to increase columns\n\n    if (columns > c) {\n      // loop new columns\n      for (j = c; j < columns; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values\n\n        if (ins) {\n          // loop rows\n          for (i = 0; i < r; i++) {\n            // add new matrix._values\n            matrix._values.push(value); // update matrix._index\n\n\n            matrix._index.push(i);\n          }\n        }\n      } // store number of matrix._values in matrix._ptr\n\n\n      matrix._ptr[columns] = matrix._values.length;\n    } else if (columns < c) {\n      // truncate matrix._ptr\n      matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index\n\n\n      matrix._values.splice(matrix._ptr[columns], matrix._values.length);\n\n      matrix._index.splice(matrix._ptr[columns], matrix._index.length);\n    } // update columns\n\n\n    c = columns; // check we need to increase rows\n\n    if (rows > r) {\n      // check we have to insert values\n      if (ins) {\n        // inserts\n        var n = 0; // loop columns\n\n        for (j = 0; j < c; j++) {\n          // update matrix._ptr for current column\n          matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values\n\n          k = matrix._ptr[j + 1] + n; // pointer\n\n          var p = 0; // loop new rows, initialize pointer\n\n          for (i = r; i < rows; i++, p++) {\n            // add value\n            matrix._values.splice(k + p, 0, value); // update matrix._index\n\n\n            matrix._index.splice(k + p, 0, i); // increment inserts\n\n\n            n++;\n          }\n        } // store number of matrix._values in matrix._ptr\n\n\n        matrix._ptr[c] = matrix._values.length;\n      }\n    } else if (rows < r) {\n      // deletes\n      var d = 0; // loop columns\n\n      for (j = 0; j < c; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column\n\n        var k0 = matrix._ptr[j];\n        var k1 = matrix._ptr[j + 1] - d; // loop matrix._index\n\n        for (k = k0; k < k1; k++) {\n          // row\n          i = matrix._index[k]; // check we need to delete value and matrix._index\n\n          if (i > rows - 1) {\n            // remove value\n            matrix._values.splice(k, 1); // remove item from matrix._index\n\n\n            matrix._index.splice(k, 1); // increase deletes\n\n\n            d++;\n          }\n        }\n      } // update matrix._ptr for current column\n\n\n      matrix._ptr[j] = matrix._values.length;\n    } // update matrix._size\n\n\n    matrix._size[0] = rows;\n    matrix._size[1] = columns; // return matrix\n\n    return matrix;\n  }\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof SparseMatrix\n   * @param {number[]} sizes          The new size the matrix should have.\n   *                                  Since sparse matrices are always two-dimensional,\n   *                                  size must be two numbers in either an array or a matrix\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n\n  SparseMatrix.prototype.reshape = function (sizes, copy) {\n    // validate arguments\n    if (!isArray(sizes)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (sizes.length !== 2) {\n      throw new Error('Sparse matrices can only be reshaped in two dimensions');\n    } // check sizes\n\n\n    sizes.forEach(function (value) {\n      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {\n        throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + format(sizes) + ')');\n      }\n    });\n    var currentLength = this._size[0] * this._size[1];\n    sizes = processSizesWildcard(sizes, currentLength);\n    var newLength = sizes[0] * sizes[1]; // m * n must not change\n\n    if (currentLength !== newLength) {\n      throw new Error('Reshaping sparse matrix will result in the wrong number of elements');\n    } // matrix to reshape\n\n\n    var m = copy ? this.clone() : this; // return unchanged if the same shape\n\n    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {\n      return m;\n    } // Convert to COO format (generate a column index)\n\n\n    var colIndex = [];\n\n    for (var i = 0; i < m._ptr.length; i++) {\n      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {\n        colIndex.push(i);\n      }\n    } // Clone the values array\n\n\n    var values = m._values.slice(); // Clone the row index array\n\n\n    var rowIndex = m._index.slice(); // Transform the (row, column) indices\n\n\n    for (var _i = 0; _i < m._index.length; _i++) {\n      var r1 = rowIndex[_i];\n      var c1 = colIndex[_i];\n      var flat = r1 * m._size[1] + c1;\n      colIndex[_i] = flat % sizes[1];\n      rowIndex[_i] = Math.floor(flat / sizes[1]);\n    } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored\n    // in column-major order, so we have to reorder the value array now. One option is to use a multisort,\n    // sorting several arrays based on some other array.\n    // OR, we could easily just:\n    // 1. Remove all values from the matrix\n\n\n    m._values.length = 0;\n    m._index.length = 0;\n    m._ptr.length = sizes[1] + 1;\n    m._size = sizes.slice();\n\n    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {\n      m._ptr[_i2] = 0;\n    } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)\n    // This step is probably the most time-consuming\n\n\n    for (var h = 0; h < values.length; h++) {\n      var _i3 = rowIndex[h];\n      var _j = colIndex[h];\n      var v = values[h];\n\n      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);\n\n      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);\n    } // The value indices are inserted out of order, but apparently that's... still OK?\n\n\n    return m;\n  };\n  /**\n   * Create a clone of the matrix\n   * @memberof SparseMatrix\n   * @return {SparseMatrix} clone\n   */\n\n\n  SparseMatrix.prototype.clone = function () {\n    var m = new SparseMatrix({\n      values: this._values ? clone(this._values) : undefined,\n      index: clone(this._index),\n      ptr: clone(this._ptr),\n      size: clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof SparseMatrix\n   * @returns {number[]} size\n   */\n\n\n  SparseMatrix.prototype.size = function () {\n    return this._size.slice(0); // copy the Array\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *\n   * @return {SparseMatrix} matrix\n   */\n\n\n  SparseMatrix.prototype.map = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke map on a Pattern only matrix');\n    } // matrix instance\n\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // invoke callback\n\n    var invoke = function invoke(v, i, j) {\n      // invoke callback\n      return callback(v, [i, j], me);\n    }; // invoke _map\n\n\n    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on the interval\n   * [minRow..maxRow, minColumn..maxColumn].\n   */\n\n\n  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {\n    // result arrays\n    var values = [];\n    var index = [];\n    var ptr = []; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype);\n    } // invoke callback\n\n\n    var invoke = function invoke(v, x, y) {\n      // invoke callback\n      v = callback(v, x, y); // check value != 0\n\n      if (!eq(v, zero)) {\n        // store value\n        values.push(v); // index\n\n        index.push(x);\n      }\n    }; // loop columns\n\n\n    for (var j = minColumn; j <= maxColumn; j++) {\n      // store pointer to values index\n      ptr.push(values.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = matrix._ptr[j];\n      var k1 = matrix._ptr[j + 1];\n\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = matrix._index[k]; // check i is in range\n\n          if (i >= minRow && i <= maxRow) {\n            // value @ k\n            invoke(matrix._values[k], i - minRow, j - minColumn);\n          }\n        }\n      } else {\n        // create a cache holding all defined values\n        var _values = {};\n\n        for (var _k = k0; _k < k1; _k++) {\n          var _i4 = matrix._index[_k];\n          _values[_i4] = matrix._values[_k];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n\n        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {\n          var value = _i5 in _values ? _values[_i5] : 0;\n          invoke(value, _i5 - minRow, j - minColumn);\n        }\n      }\n    } // store number of values in ptr\n\n\n    ptr.push(values.length); // return sparse matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]\n    });\n  }\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *                              If false, the indices are guaranteed to be in order,\n   *                              if true, the indices can be unordered.\n   */\n\n\n  SparseMatrix.prototype.forEach = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke forEach on a Pattern only matrix');\n    } // matrix instance\n\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = this._index[k]; // value @ k\n\n          callback(this._values[k], [i, j], me);\n        }\n      } else {\n        // create a cache holding all defined values\n        var values = {};\n\n        for (var _k2 = k0; _k2 < k1; _k2++) {\n          var _i6 = this._index[_k2];\n          values[_i6] = this._values[_k2];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n\n        for (var _i7 = 0; _i7 < rows; _i7++) {\n          var value = _i7 in values ? values[_i7] : 0;\n          callback(value, [_i7, j], me);\n        }\n      }\n    }\n  };\n  /**\n   * Iterate over the matrix elements, skipping zeros\n   * @return {Iterable<{ value, index: number[] }>}\n   */\n\n\n  SparseMatrix.prototype[Symbol.iterator] = function* () {\n    if (!this._values) {\n      throw new Error('Cannot iterate a Pattern only matrix');\n    }\n\n    var columns = this._size[1];\n\n    for (var j = 0; j < columns; j++) {\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        var i = this._index[k];\n        yield {\n          value: this._values[k],\n          index: [i, j]\n        };\n      }\n    }\n  };\n  /**\n   * Create an Array with a copy of the data of the SparseMatrix\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n\n\n  SparseMatrix.prototype.toArray = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, true);\n  };\n  /**\n   * Get the primitive value of the SparseMatrix: a two dimensions array\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n\n\n  SparseMatrix.prototype.valueOf = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, false);\n  };\n\n  function _toArray(values, index, ptr, size, copy) {\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1]; // result\n\n    var a = []; // vars\n\n    var i, j; // initialize array\n\n    for (i = 0; i < rows; i++) {\n      a[i] = [];\n\n      for (j = 0; j < columns; j++) {\n        a[i][j] = 0;\n      }\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        i = index[k]; // set value (use one for pattern matrix)\n\n        a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;\n      }\n    }\n\n    return a;\n  }\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof SparseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  SparseMatrix.prototype.format = function (options) {\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // density\n\n    var density = this.density(); // rows & columns\n\n    var str = 'Sparse Matrix [' + format(rows, options) + ' x ' + format(columns, options) + '] density: ' + format(density, options) + '\\n'; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        var i = this._index[k]; // append value\n\n        str += '\\n    (' + format(i, options) + ', ' + format(j, options) + ') ==> ' + (this._values ? format(this._values[k], options) : 'X');\n      }\n    }\n\n    return str;\n  };\n  /**\n   * Get a string representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {string} str\n   */\n\n\n  SparseMatrix.prototype.toString = function () {\n    return format(this.toArray());\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {Object}\n   */\n\n\n  SparseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'SparseMatrix',\n      values: this._values,\n      index: this._index,\n      ptr: this._ptr,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof SparseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix vector with the diagonal values.\n   */\n\n\n  SparseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays\n\n    var values = [];\n    var index = [];\n    var ptr = []; // initial ptr value\n\n    ptr[0] = 0; // loop columns\n\n    for (var j = kSuper; j < columns && values.length < n; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop x within [k0, k1[\n\n      for (var x = k0; x < k1; x++) {\n        // row index\n        var i = this._index[x]; // check row\n\n        if (i === j - kSuper + kSub) {\n          // value on this column\n          values.push(this._values[x]); // store row\n\n          index[values.length - 1] = i - kSub; // exit loop\n\n          break;\n        }\n      }\n    } // close ptr\n\n\n    ptr.push(values.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [n, 1]\n    });\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof SparseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SparseMatrix\", \"values\": [], \"index\": [], \"ptr\": [], \"size\": []}`,\n   *                       where mathjs is optional\n   * @returns {SparseMatrix}\n   */\n\n\n  SparseMatrix.fromJSON = function (json) {\n    return new SparseMatrix(json);\n  };\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {Array} size                       The matrix size.\n   * @param {number | Array | Matrix } value   The values for the diagonal.\n   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]            The default value for non-diagonal\n   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.\n   *\n   * @returns {SparseMatrix}\n   */\n\n\n  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if (isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    } // equal signature to use\n\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (isMatrix(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // create arrays\n\n\n    var values = [];\n    var index = [];\n    var ptr = []; // loop items\n\n    for (var j = 0; j < columns; j++) {\n      // number of rows with value\n      ptr.push(values.length); // diagonal index\n\n      var i = j - kSuper; // check we need to set diagonal value\n\n      if (i >= 0 && i < n) {\n        // get value @ i\n        var v = _value(i); // check for zero\n\n\n        if (!eq(v, zero)) {\n          // column\n          index.push(i + kSub); // add value\n\n          values.push(v);\n        }\n      }\n    } // last value should be number of values\n\n\n    ptr.push(values.length); // create SparseMatrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [rows, columns]\n    });\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n\n  SparseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]); // swap rows\n\n    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance\n\n\n    return this;\n  };\n  /**\n   * Loop rows with data in column j.\n   *\n   * @param {number} j            Column\n   * @param {Array} values        Matrix values\n   * @param {Array} index         Matrix row indeces\n   * @param {Array} ptr           Matrix column pointers\n   * @param {Function} callback   Callback function invoked for every row in column j\n   */\n\n\n  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {\n    // indeces for column j\n    var k0 = ptr[j];\n    var k1 = ptr[j + 1]; // loop\n\n    for (var k = k0; k < k1; k++) {\n      // invoke callback\n      callback(index[k], values[k]);\n    }\n  };\n  /**\n   * Swap rows x and y in Sparse Matrix data structures.\n   *\n   * @param {number} x         Matrix row index 1\n   * @param {number} y         Matrix row index 2\n   * @param {number} columns   Number of columns in matrix\n   * @param {Array} values     Matrix values\n   * @param {Array} index      Matrix row indeces\n   * @param {Array} ptr        Matrix column pointers\n   */\n\n\n  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // find value index @ x\n\n      var kx = _getValueIndex(x, k0, k1, index); // find value index @ x\n\n\n      var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix\n\n\n      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {\n        // swap values (check for pattern matrix)\n        if (values) {\n          var v = values[kx];\n          values[kx] = values[ky];\n          values[ky] = v;\n        } // next column\n\n\n        continue;\n      } // check x row exist & no y row\n\n\n      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {\n        // value @ x (check for pattern matrix)\n        var vx = values ? values[kx] : undefined; // insert value @ y\n\n        index.splice(ky, 0, y);\n\n        if (values) {\n          values.splice(ky, 0, vx);\n        } // remove value @ x (adjust array index if needed)\n\n\n        index.splice(ky <= kx ? kx + 1 : kx, 1);\n\n        if (values) {\n          values.splice(ky <= kx ? kx + 1 : kx, 1);\n        } // next column\n\n\n        continue;\n      } // check y row exist & no x row\n\n\n      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {\n        // value @ y (check for pattern matrix)\n        var vy = values ? values[ky] : undefined; // insert value @ x\n\n        index.splice(kx, 0, x);\n\n        if (values) {\n          values.splice(kx, 0, vy);\n        } // remove value @ y (adjust array index if needed)\n\n\n        index.splice(kx <= ky ? ky + 1 : ky, 1);\n\n        if (values) {\n          values.splice(kx <= ky ? ky + 1 : ky, 1);\n        }\n      }\n    }\n  };\n\n  return SparseMatrix;\n}, {\n  isClass: true\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}