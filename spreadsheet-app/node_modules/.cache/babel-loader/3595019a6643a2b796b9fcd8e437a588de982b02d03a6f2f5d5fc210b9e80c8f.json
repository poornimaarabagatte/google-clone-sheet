{"ast":null,"code":"import { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (!isNode(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!isNode(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!isNode(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isBigNumber","isComplex","isNode","isUnit","typeOf","factory","getPrecedence","name","dependencies","createConditionalNode","_ref","Node","ConditionalNode","condition","trueExpr","falseExpr","SyntaxError","TypeError","prototype","type","isConditionalNode","_compile","math","argNames","evalCondition","evalTrueExpr","evalFalseExpr","evalConditionalNode","scope","args","context","testCondition","forEach","callback","map","_ifNode","clone","_toString","options","parenthesis","precedence","toString","conditionPrecedence","truePrecedence","falsePrecedence","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isZero","re","im","value","undefined","isClass"],"sources":["/Users/poornima/Desktop/Google_Sheet/spreadsheet-app/node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js"],"sourcesContent":["import { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!isNode(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!isNode(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!isNode(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}